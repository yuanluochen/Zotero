C++ Primer Plus
Sixth Edition


informit.com/devlibrary
Developer’s Library
ESSENTIAL REFERENCES FOR PROGRAMMING PROFESSIONALS
Developer’s Library books are designed to provide practicing programmers with unique, high-quality references and tutorials on the programming languages and technologies they use in their daily work.
All books in the Developer’s Library are written by expert technology practitioners who are especially skilled at organizing and presenting information in a way that’s useful for other programmers.
Key titles include some of the best, most widely acclaimed books within their topic areas:
PHP & MySQL Web Development Luke Welling & Laura Thomson ISBN-13: 978-0-672-32916-6
MySQL
Paul DuBois ISBN-13: 978-0-672-32938-8
Linux Kernel Development Robert Love ISBN-13: 978-0-672-32946-3
Python Essential Reference David Beazley ISBN-13: 978-0-672-32862-6
PostgreSQL Korry Douglas ISBN-13: 978-0-672-32756-8
C++ Primer Plus Stephen Prata ISBN-13: 978-0-321-77640-2
Developer’s Library books are available at most retail and online bookstores, as well as by subscription from Safari Books Online at safari.informit.com.
Developer’s Library


C++ Primer Plus
Sixth Edition
Stephen Prata
Upper Saddle River, NJ • Boston • Indianapolis • San Francisco New York • Toronto • Montreal • London • Munich • Paris • Madrid Cape Town • Sydney • Tokyo • Singapore • Mexico City


Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals.
The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.
The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or special sales, which may include electronic versions and/or custom covers and content particular to your business, training goals, marketing focus, and branding interests. For more information, please contact:
U.S. Corporate and Government Sales (800) 382-3419 corpsales@pearsontechgroup.com
For sales outside the United States, please contact:
International Sales international@pearson.com
Visit us on the Web: informit.com/aw.
Library of Congress Cataloging-in-Publication data is on file.
Copyright © 2012 Pearson Education, Inc.
All rights reserved. Printed in the United States of America. This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise. To obtain permission to use material from this work, please submit a written request to Pearson Education, Inc., Permissions Department, One Lake Street, Upper Saddle River, New Jersey 07458, or you may fax your request to (201) 236-3290.
ISBN-13: 978-0-321-77640-2 ISBN-10: 0-321-77640-2
Text printed in the United States on recycled paper at R.R. Donnelley in Crawfordsville, Indiana.
Acquisitions Editor Mark Taber
Development Editor
Michael Thurston
Managing Editor Kristy Hart
Project Editors Samantha Sinkhorn
Jovana Shirley
Copy Editor Bart Reed
Indexer
Lisa Stumpf
Proofreader Language Logistics, LLC
Technical Reviewer David Horvath
Publishing Coordinator
Vanessa Evans
Cover Designer Gary Adair
Compositor Nonie Ratcliff
Second printing: January 2012


❖
To my parents, with love.
❖


Contents at a Glance
Introduction 1
1 Getting Started with C++ 9
2 Setting Out to C++ 27
3 Dealing with Data 65
4 Compound Types 115
5 Loops and Relational Expressions 195
6 Branching Statements and Logical Operators 253
7 Functions: C++’s Programming Modules 305
8 Adventures in Functions 379
9 Memory Models and Namespaces 447
10 Objects and Classes 505
11 Working with Classes 563
12 Classes and Dynamic Memory Allocation 627
13 Class Inheritance 707
14 Reusing Code in C++ 785
15 Friends, Exceptions, and More 877
16 The string Class and the Standard Template Library 951
17 Input, Output, and Files 1061
18 Visiting with the New C++ Standard 1153


Appendixes
A Number Bases 1215
B C++ Reserved Words 1221
C The ASCII Character Set 1225
D Operator Precedence 1231
E Other Operators 1235
F The string Template Class 1249
G The Standard Template Library Methods and Functions 1271
H Selected Readings and Internet Resources 1323
I Converting to ISO Standard C++ 1327
J Answers to Chapter Reviews 1335
Index 1367


Table of Contents
Introduction 1
1 Getting Started with C++ 9
Learning C++: What Lies Before You 10 The Origins of C++: A Little History 10 Portability and Standards 15 The Mechanics of Creating a Program 18 Summary 25
2 Setting Out to C++ 27 C++ Initiation 27 C++ Statements 41 More C++ Statements 45 Functions 48 Summary 61 Chapter Review 62 Programming Exercises 62
3 Dealing with Data 65 Simple Variables 66 The const Qualifier 90 Floating-Point Numbers 92 C++ Arithmetic Operators 97 Summary 109 Chapter Review 110 Programming Exercises 111
4 Compound Types 115 Introducing Arrays 116 Strings 120 Introducing the string Class 131 Introducing Structures 140 Unions 149 Enumerations 150 Pointers and the Free Store 153 Pointers, Arrays, and Pointer Arithmetic 167 Combinations of Types 184 Array Alternatives 186 Summary 190 Chapter Review 191 Programming Exercises 192


ix
Contents
5 Loops and Relational Expressions 195 Introducing for Loops 196 The while Loop 224 The do while Loop 231 The Range-Based for Loop (C++11) 233 Loops and Text Input 234 Nested Loops and Two-Dimensional Arrays 244 Summary 249 Chapter Review 250 Programming Exercises 251
6 Branching Statements and Logical Operators 253 The if Statement 254 Logical Expressions 260 The cctype Library of Character Functions 270 The ?: Operator 273 The switch Statement 274 The break and continue Statements 280 Number-Reading Loops 283 Simple File Input/Output 287 Summary 298 Chapter Review 298 Programming Exercises 301
7 Functions: C++’s Programming Modules 305 Function Review 306 Function Arguments and Passing by Value 313 Functions and Arrays 320 Functions and Two-Dimensional Arrays 337 Functions and C-Style Strings 339 Functions and Structures 343 Functions and string Class Objects 353 Functions and array Objects 355 Recursion 357 Pointers to Functions 361 Summary 371 Chapter Review 372 Programming Exercises 374
8 Adventures in Functions 379 C++ Inline Functions 379 Reference Variables 383 Default Arguments 409 Function Overloading 412 Function Templates 419


x Contents
Summary 442 Chapter Review 443 Programming Exercises 444
9 Memory Models and Namespaces 447 Separate Compilation 447 Storage Duration, Scope, and Linkage 453 Namespaces 482 Summary 497 Chapter Review 498 Programming Exercises 501
10 Objects and Classes 505
Procedural and Object-Oriented Programming 506 Abstraction and Classes 507 Class Constructors and Destructors 524 Knowing Your Objects: The this Pointer 539 An Array of Objects 546 Class Scope 549 Abstract Data Types 552 Summary 557 Chapter Review 558 Programming Exercises 559
11 Working with Classes 563 Operator Overloading 564 Time on Our Hands: Developing an Operator Overloading Example 565 Introducing Friends 578 Overloaded Operators: Member Versus Nonmember Functions 587 More Overloading: A Vector Class 588 Automatic Conversions and Type Casts for Classes 606 Summary 621 Chapter Review 623 Programming Exercises 623
12 Classes and Dynamic Memory Allocation 627 Dynamic Memory and Classes 628 The New, Improved String Class 647 Things to Remember When Using new in Constructors 659 Observations About Returning Objects 662 Using Pointers to Objects 665 Reviewing Techniques 676 A Queue Simulation 678


xi
Contents
Summary 699 Chapter Review 700 Programming Exercises 702
13 Class Inheritance 707
Beginning with a Simple Base Class 708 Inheritance: An Is-a Relationship 720 Polymorphic Public Inheritance 722 Static and Dynamic Binding 737 Access Control: protected 745 Abstract Base Classes 746 Inheritance and Dynamic Memory Allocation 757 Class Design Review 766 Summary 778 Chapter Review 779 Programming Exercises 780
14 Reusing Code in C++ 785
Classes with Object Members 786 Private Inheritance 797 Multiple Inheritance 808 Class Templates 830 Summary 866 Chapter Review 869 Programming Exercises 871
15 Friends, Exceptions, and More 877 Friends 877 Nested Classes 889 Exceptions 896 Runtime Type Identification 933 Type Cast Operators 943 Summary 947 Chapter Review 947 Programming Exercises 949
16 The string Class and the Standard Template Library 951 The string Class 952 Smart Pointer Template Classes 968 The Standard Template Library 978 Generic Programming 992 Function Objects (a.k.a. Functors) 1026 Algorithms 1035 Other Libraries 1045


xii Contents
Summary 1054 Chapter Review 1056 Programming Exercises 1057
17 Input, Output, and Files 1061
An Overview of C++ Input and Output 1062 Output with cout 1069 Input with cin 1093 File Input and Output 1114 Incore Formatting 1142 Summary 1145 Chapter Review 1146 Programming Exercises 1148
18 Visiting with the New C++ Standard 1153 C++11 Features Revisited 1153 Move Semantics and the Rvalue Reference 1164 New Class Features 1178 Lambda Functions 1184 Wrappers 1191 Variadic Templates 1197 More C++11 Features 1202 Language Change 1205 What Now? 1207 Summary 1208 Chapter Review 1209 Programming Exercises 1212
Appendixes
A Number Bases 1215
B C++ Reserved Words 1221
C The ASCII Character Set 1225
D Operator Precedence 1231
E Other Operators 1235
F The string Template Class 1249
G The Standard Template Library Methods and Functions 1271
H Selected Readings and Internet Resources 1323
I Converting to ISO Standard C++ 1327
J Answers to Chapter Reviews 1335
Index 1367


Acknowledgments
Acknowledgments for the Sixth Edition
I’d like to thank Mark Taber and Samantha Sinkhorn of Pearson for guiding and managing this project and David Horvath for providing technical review and editing.
Acknowledgments for the Fifth Edition
I’d like to thank Loretta Yates and Songlin Qiu of Sams Publishing for guiding and managing this project.Thanks to my colleague Fred Schmitt for several useful suggestions. Once again, I’d like to thank Ron Liechty of Metrowerks for his helpfulness.
Acknowledgments for the Fourth Edition
Several editors from Pearson and from Sams helped originate and maintain this project; thanks to Linda Sharp, Karen Wachs, and Laurie McGuire.Thanks, too, to Michael Maddox, Bill Craun, Chris Maunder, and Phillipe Bruno for providing technical review and editing. And thanks again to Michael Maddox and Bill Craun for supplying the material for the Real World Notes. Finally, I’d like to thank Ron Liechty of Metrowerks and Greg Comeau of Comeau Computing for their aid with C++ compilers.
Acknowledgments for the Third Edition
I’d like to thank the editors from Macmillan and The Waite Group for the roles they played in putting this book together:Tracy Dunkelberger, Susan Walton, and Andrea Rosenberg.Thanks, too, to Russ Jacobs for his content and technical editing. From Metrowerks, I’d like to thank Dave Mark, Alex Harper, and especially Ron Liechty, for their help and cooperation.
Acknowledgments for the Second Edition
I’d like to thank Mitchell Waite and Scott Calamar for supporting a second edition and Joel Fugazzotto and Joanne Miller for guiding the project to completion.Thanks to Michael Marcotty of Metrowerks for dealing with my questions about their beta version CodeWarrior compiler. I’d also like to thank the following instructors for taking the time to give us feedback on the first edition: Jeff Buckwalter, Earl Brynner, Mike Holland, Andy Yao, Larry Sanders, Shahin Momtazi, and Don Stephens. Finally, I wish to thank Heidi Brumbaugh for her helpful content editing of new and revised material.
Acknowledgments for the First Edition
Many people have contributed to this book. In particular, I wish to thank Mitch Waite for his work in developing, shaping, and reshaping this book, and for reviewing the manuscript. I appreciate Harry Henderson’s work in reviewing the last few chapters and in


testing programs with the Zortech C++ compiler.Thanks to David Gerrold for reviewing the entire manuscript and for championing the needs of less-experienced readers. Also thanks to Hank Shiffman for testing programs using Sun C++ and to Kent Williams for testing programs with AT&T cfront and with G++.Thanks to Nan Borreson of Borland International for her responsive and cheerful assistance with Turbo C++ and Borland C++.Thank you, Ruth Myers and Christine Bush, for handling the relentless paper flow involved with this kind of project. Finally, thanks to Scott Calamar for keeping everything on track.
About the Author
Stephen Prata taught astronomy, physics, and computer science at the College of Marin in Kentfield, California. He received his B.S. from the California Institute of Technology and his Ph.D. from the University of California, Berkeley. He has authored or coauthored more than a dozen books on programming topics including New C Primer Plus, which received the Computer Press Association’s 1990 Best How-to Computer Book Award, and C++ Primer Plus, nominated for the Computer Press Association’s Best How-to Computer Book Award in 1991.
We Want to Hear from You!
As the reader of this book, you are our most important critic and commentator.We value your opinion and want to know what we’re doing right, what we could do better, what areas you’d like to see us publish in, and any other words of wisdom you’re willing to pass our way.
You can email or write directly to let us know what you did or didn’t like about this book—as well as what we can do to make our books stronger.
Please note that we cannot help you with technical problems related to the topic of this book, and that due to the high volume of mail we receive, we might not be able to reply to every message.
When you write, please be sure to include this book’s title and author as well as your name, email address, and phone number.
Email: feedback@developers-library.info Mail: Reader Feedback Addison-Wesley Developer’s Library 800 East 96th Street Indianapolis, IN 46240 USA
Reader Services
Visit our website and register this book at www.informit.com/register for convenient access to any updates, downloads, or errata that might be available for this book.


Introduction
L
earning C++ is an adventure of discovery, particularly because the language accommodates several programming paradigms, including object-oriented programming, generic programming, and the traditional procedural programming.The fifth edition of this book described the language as set forth in the ISO C++ standards, informally known as C++99 and C++03, or, sometimes as C++99/03. (The 2003 version was largely a technical correction to the 1999 standard and didn’t add any new features.) Since then, C++ continues to evolve.As this book is written, the international C++ Standards Committee has just approved a new version of the standard.This standard had the informal name of C++0x while in development, and now it will be known as C++11. Most contemporary compilers support C++99/03 quite well, and most of the examples in this book comply with that standard. But many features of the new standard already have appeared in some implementations, and this edition of C++ Primer Plus explores these new features. C++ Primer Plus discusses the basic C language and presents C++ features, making this book self-contained. It presents C++ fundamentals and illustrates them with short, to-the-point programs that are easy to copy and experiment with.You learn about input/output (I/O), how to make programs perform repetitive tasks and make choices, the many ways to handle data, and how to use functions.You learn about the many features C++ has added to C, including the following:
n Classes and objects
n Inheritance
n Polymorphism, virtual functions, and runtime type identification (RTTI)
n Function overloading
n Reference variables
n Generic, or type-independent, programming, as provided by templates and the Standard Template Library (STL)
n The exception mechanism for handling error conditions
n Namespaces for managing names of functions, classes, and variables


2 Introduction
The Primer Approach
C++ Primer Plus brings several virtues to the task of presenting all this material. It builds on the primer tradition begun by C Primer Plus nearly two decades ago and embraces its successful philosophy:
n A primer should be an easy-to-use, friendly guide.
n A primer doesn’t assume that you are already familiar with all relevant programming concepts.
n A primer emphasizes hands-on learning with brief, easily typed examples that develop your understanding, a concept or two at a time.
n A primer clarifies concepts with illustrations.
n A primer provides questions and exercises to let you test your understanding, making the book suitable for self-learning or for the classroom.
Following these principles, the book helps you understand this rich language and how to use it. For example
n It provides conceptual guidance about when to use particular features, such as using public inheritance to model what are known as is-a relationships.
n It illustrates common C++ programming idioms and techniques.
n It provides a variety of sidebars, including tips, cautions and notes.
The author and editors of this book do our best to keep the presentation to-the-point, simple, and fun. Our goal is that by the end of the book, you’ll be able to write solid, effective programs and enjoy yourself doing so.
Sample Code Used in This Book
This book provides an abundance of sample code, most of it in the form of complete programs. Like the previous editions, this book practices generic C++ so that it is not tied to any particular kind of computer, operating system, or compiler.Thus, the examples were tested on a Windows 7 system, a Macintosh OS X system, and a Linux system. Those programs using C++11 features require compilers supporting those features, but the remaining programs should work with any C++99/03-compliant system. The sample code for the complete programs described in this book is available on this book’s website. See the registration link given on the back cover for more information.
How This Book Is Organized
This book is divided into 18 chapters and 10 appendixes, summarized here:
n Chapter 1: Getting Started with C++—Chapter 1 relates how Bjarne Stroustrup created the C++ programming language by adding object-oriented programming


3
How This Book Is Organized
support to the C language.You’ll learn the distinctions between procedural languages, such as C, and object-oriented languages, such as C++.You’ll read about the joint ANSI/ISO work to develop a C++ standard.This chapter discusses the mechanics of creating a C++ program, outlining the approach for several current C++ compilers. Finally, it describes the conventions used in this book.
n Chapter 2: Setting Out to C++—Chapter 2 guides you through the process of creating simple C++ programs.You’ll learn about the role of the main() function and about some of the kinds of statements that C++ programs use.You’ll use the predefined cout and cin objects for program output and input, and you’ll learn about creating and using variables. Finally, you’ll be introduced to functions, C++’s programming modules.
n Chapter 3: Dealing with Data—C++ provides built-in types for storing two kinds of data: integers (numbers with no fractional parts) and floating-point numbers (numbers with fractional parts).To meet the diverse requirements of programmers, C++ offers several types in each category. Chapter 3 discusses those types, including creating variables and writing constants of various types.You’ll also learn how C++ handles implicit and explicit conversions from one type to another.
n Chapter 4: Compound Types—C++ lets you construct more elaborate types from the basic built-in types.The most advanced form is the class, discussed in Chapters 9 through 13. Chapter 4 discusses other forms, including arrays, which hold several values of a single type; structures, which hold several values of unlike types; and pointers, which identify locations in memory.You’ll also learn how to create and store text strings and to handle text I/O by using C-style character arrays and the C++ string class. Finally, you’ll learn some of the ways C++ handles memory allocation, including using the new and delete operators for managing memory explicitly.
n Chapter 5: Loops and Relational Expressions—Programs often must perform repetitive actions, and C++ provides three looping structures for that purpose: the for loop, the while loop, and the do while loop. Such loops must know when they should terminate, and the C++ relational operators enable you to create tests to guide such loops. In Chapter 5 you learn how to create loops that read and process input character-by-character. Finally, you’ll learn how to create two-dimensional arrays and how to use nested loops to process them.
n Chapter 6: Branching Statements and Logical Operators—Programs can behave intelligently if they can tailor their behavior to circumstances. In Chapter 6 you’ll learn how to control program flow by using the if, if else, and switch statements and the conditional operator.You’ll learn how to use logical operators to help express decision-making tests.Also, you’ll meet the cctype library of functions for evaluating character relations, such as testing whether a character is a digit or a nonprinting character. Finally, you’ll get an introductory view of file I/O.


4 Introduction
n Chapter 7: Functions: C++’s Programming Modules—Functions are the basic building blocks of C++ programming. Chapter 7 concentrates on features that C++ functions share with C functions. In particular, you’ll review the general format of a function definition and examine how function prototypes increase the reliability of programs.Also, you’ll investigate how to write functions to process arrays, character strings, and structures. Next, you’ll learn about recursion, which is when a function calls itself, and see how it can be used to implement a divide-andconquer strategy. Finally, you’ll meet pointers to functions, which enable you to use a function argument to tell one function to use a second function.
n Chapter 8: Adventures in Functions—Chapter 8 explores the new features C++ adds to functions.You’ll learn about inline functions, which can speed program execution at the cost of additional program size.You’ll work with reference variables, which provide an alternative way to pass information to functions. Default arguments let a function automatically supply values for function arguments that you omit from a function call. Function overloading lets you create functions having the same name but taking different argument lists.All these features have frequent use in class design.Also you’ll learn about function templates, which allow you to specify the design of a family of related functions.
n Chapter 9: Memory Models and Namespaces—Chapter 9 discusses putting
together multifile programs. It examines the choices in allocating memory, looking at different methods of managing memory and at scope, linkage, and namespaces, which determine what parts of a program know about a variable.
n Chapter 10: Objects and Classes—A class is a user-defined type, and an object (such as a variable) is an instance of a class. Chapter 10 introduces you to objectoriented programming and to class design.A class declaration describes the information stored in a class object and also the operations (class methods) allowed for class objects. Some parts of an object are visible to the outside world (the public portion), and some are hidden (the private portion). Special class methods (constructors and destructors) come into play when objects are created and destroyed. You will learn about all this and other class details in this chapter, and you’ll see how classes can be used to implement ADTs, such as a stack.
n Chapter 11: Working with Classes—In Chapter 11 you’ll further your understanding of classes. First, you’ll learn about operator overloading, which lets you define how operators such as + will work with class objects.You’ll learn about friend functions, which can access class data that’s inaccessible to the world at large. You’ll see how certain constructors and overloaded operator member functions can be used to manage conversion to and from class types.
n Chapter 12: Classes and Dynamic Memory Allocation—Often it’s useful to have a class member point to dynamically allocated memory. If you use new in a class constructor to allocate dynamic memory, you incur the responsibilities of providing an appropriate destructor, of defining an explicit copy constructor, and of


5
How This Book Is Organized
defining an explicit assignment operator. Chapter 12 shows you how and discusses the behavior of the member functions generated implicitly if you fail to provide explicit definitions.You’ll also expand your experience with classes by using pointers to objects and studying a queue simulation problem.
n Chapter 13: Class Inheritance—One of the most powerful features of object-oriented programming is inheritance, by which a derived class inherits the features of a base class, enabling you to reuse the base class code. Chapter 13 discusses public inheritance, which models is-a relationships, meaning that a derived object is a special case of a base object. For example, a physicist is a special case of a scientist. Some inheritance relationships are polymorphic, meaning you can write code using a mixture of related classes for which the same method name may invoke behavior that depends on the object type. Implementing this kind of behavior necessitates using a new kind of member function called a virtual function. Sometimes using abstract base classes is the best approach to inheritance relationships.This chapter discusses these matters, pointing out when public inheritance is appropriate and when it is not.
n Chapter 14: Reusing Code in C++—Public inheritance is just one way to reuse code. Chapter 14 looks at several other ways. Containment is when one class contains members that are objects of another class. It can be used to model has-a relationships, in which one class has components of another class. For example, an automobile has a motor.You also can use private and protected inheritance to model such relationships.This chapter shows you how and points out the differences among the different approaches.Also, you’ll learn about class templates, which let you define a class in terms of some unspecified generic type, and then use the template to create specific classes in terms of specific types. For example, a stack template enables you to create a stack of integers or a stack of strings. Finally, you’ll learn about multiple public inheritance, whereby a class can derive from more than one class.
n Chapter 15: Friends, Exceptions, and More—Chapter 15 extends the discussion of friends to include friend classes and friend member functions.Then it presents several new developments in C++, beginning with exceptions, which provide a mechanism for dealing with unusual program occurrences, such an inappropriate function argument values and running out of memory.Then you’ll learn about RTTI, a mechanism for identifying object types. Finally, you’ll learn about the safer alternatives to unrestricted typecasting.
n Chapter 16: The string Class and the Standard Template Library—Chapter 16 discusses some useful class libraries recently added to the language.The string class is a convenient and powerful alternative to traditional C-style strings.The auto_ptr class helps manage dynamically allocated memory.The STL provides several generic containers, including template representations of arrays, queues, lists, sets, and maps. It also provides an efficient library of generic algorithms that can be used with STL


6 Introduction
containers and also with ordinary arrays.The valarray template class provides support for numeric arrays.
n Chapter 17: Input, Output, and Files—Chapter 17 reviews C++ I/O and discusses how to format output.You’ll learn how to use class methods to determine the state of an input or output stream and to see, for example, whether there has been a type mismatch on input or whether the end-of-file has been detected. C++ uses inheritance to derive classes for managing file input and output.You’ll learn how to open files for input and output, how to append data to a file, how to use binary files, and how to get random access to a file. Finally, you’ll learn how to apply standard I/O methods to read from and write to strings.
n Chapter 18:Visiting with the New C++ Standard—Chapter 18 begins by reviewing several C++11 features introduced in earlier chapters, including new types, uniform initialization syntax, automatic type deduction, new smart pointers, and scoped enumerations.The chapter then discusses the new rvalue reference type and how it’s used to implement a new feature called move semantics. Next, the chapter covers new class features, lambda expressions, and variadic templates. Finally, the chapter outlines many new features not covered in earlier chapters of the book.
n Appendix A: Number Bases—Appendix A discusses octal, hexadecimal, and binary numbers.
n Appendix B: C++ Reserved Words—Appendix B lists C++ keywords.
n Appendix C: The ASCII Character Set—Appendix C lists the ASCII character set, along with decimal, octal, hexadecimal, and binary representations.
n Appendix D: Operator Precedence—Appendix D lists the C++ operators in order of decreasing precedence.
n Appendix E: Other Operators—Appendix E summarizes the C++ operators, such as the bitwise operators, not covered in the main body of the text.
n Appendix F: The string Template Class—Appendix F summarizes string
class methods and functions.
n Appendix G: The Standard Template Library Methods and FunctionsAppendix G summarizes the STL container methods and the general STL algorithm functions.
n Appendix H: Selected Readings and Internet Resources—Appendix H lists some books that can further your understanding of C++.
n Appendix I: Converting to ISO Standard C++—Appendix I provides guidelines for moving from C and older C++ implementations to ANSI/ISO C++.
n Appendix J: Answers to Chapter Review—Appendix J contains the answers to the review questions posed at the end of each chapter.


7
Note to Instructors
Note to Instructors
One of the goals of this edition of C++ Primer Plus is to provide a book that can be used as either a teach-yourself book or as a textbook. Here are some of the features that support using C++ Primer Plus, Sixth Edition, as a textbook:
n This book describes generic C++, so it isn’t dependent on a particular implementation.
n The contents track the ISO/ANSI C++ standards committee’s work and include discussions of templates, the STL, the string class, exceptions, RTTI, and namespaces.
n It doesn’t assume prior knowledge of C, so it can be used without a C prerequisite. (Some programming background is desirable, however.)
n Topics are arranged so that the early chapters can be covered rapidly as review chapters for courses that do have a C prerequisite.
n Chapters include review questions and programming exercises.Appendix J provides the answers to the review questions.
n The book introduces several topics that are appropriate for computer science courses, including abstract data types (ADTs), stacks, queues, simple lists, simulations, generic programming, and using recursion to implement a divide-and-conquer strategy.
n Most chapters are short enough to cover in a week or less.
n The book discusses when to use certain features as well as how to use them. For example, it links public inheritance to is-a relationships and composition and private inheritance to has-a relationships, and it discusses when to use virtual functions and when not to.
Conventions Used in This Book
This book uses several typographic conventions to distinguish among various kinds of text:
n Code lines, commands, statements, variables, filenames, and program output appear
in a computer typeface:
#include <iostream>
int main()
{
using namespace std;
cout << "What’s up, Doc!\n";
return 0;
}


8 Introduction
n Program input that you should type appears in bold computer typeface:
Please enter your name:
Plato
n Placeholders in syntax descriptions appear in an italic computer typeface.You should replace a placeholder with the actual filename, parameter, or whatever element it represents.
n Italic type is used for new terms.
Sidebar
A sidebar provides a deeper discussion or additional background to help illuminate a topic.
Tip
Tips present short, helpful guides to particular programming situations.
Caution
A caution alerts you to potential pitfalls.
Note
The notes provide a catch-all category for comments that don’t fall into one of the other categories.
Systems Used to Develop This Book’s Programming Examples
For the record, the C++11 examples in this book were developed using Microsoft Visual C++ 2010 and Cygwin with Gnu g++ 4.5.0, both running under 64-bit Windows 7. The remaining examples were tested with these systems, as well as on an iMac using g++ 4.2.1 under OS X 10.6.8 and on an Ubuntu Linux system using g++ 4.4.1. Most of the pre-C++11 examples were originally developed using Microsoft Visual C++ 2003 and Metrowerks CodeWarrior Development Studio 9 running under Windows XP Professional and checked using the Borland C++ 5.5 command-line compiler and GNU gpp 3.3.3 on the same system, using Comeau 4.3.3 and GNU g++ 3.3.1 under SuSE 9.0 Linux, and using Metrowerks Development Studio 9 on a Macintosh G4 under OS 10.3. C++ offers a lot to the programmer; learn and enjoy!


1
Getting Started with C++
I
n this chapter you’ll learn about the following:
n The history and philosophy of C and of C++
n Procedural versus object-oriented programming
n How C++ adds object-oriented concepts to the C language
n How C++ adds generic programming concepts to the C language
n Programming language standards
n The mechanics of creating a program
Welcome to C++! This exciting language, which blends the C language with support for object-oriented programming and for generic programming, became one of the most important programming languages of the 1990s and continues strongly in the 2000s. Its C ancestry brings to C++ the tradition of an efficient, compact, fast, and portable language. Its object-oriented heritage brings C++ a fresh programming methodology, designed to cope with the escalating complexity of modern programming tasks. Its template features bring yet another new programming methodology: generic programming.This triple heritage is both a blessing and a bane. It makes the language very powerful, but it also means there’s a lot to learn. This chapter explores C++’s background further and then goes over some of the ground rules for creating C++ programs.The rest of the book teaches you to use the C++ language, going from the modest basics of the language to the glory of object-oriented programming (OOP) and its supporting cast of new jargon—objects, classes, encapsulation, data hiding, polymorphism, and inheritance—and then on to its support of generic programming. (Of course, as you learn C++, these terms will be transformed from buzzwords to the necessary vocabulary of cultivated discourse.)


10 Chapter 1 Getting Started with C++
Learning C++: What Lies Before You
C++ joins three separate programming categories: the procedural language, represented by C; the object-oriented language, represented by the class enhancements C++ adds to C; and generic programming, supported by C++ templates.This chapter looks into those traditions. But first, let’s consider what this heritage implies about learning C++. One reason to use C++ is to avail yourself of its object-oriented features.To do so, you need a sound background in standard C, for that language provides the basic types, operators, control structures, and syntax rules. So if you already know C, you’re poised to learn C++. But it’s not just a matter of learning a few more keywords and constructs. Going from C to C++ involves perhaps more work than learning C in the first place. Also if you know C, you must unlearn some programming habits as you make the transition to C++. If you don’t know C, you have to master the C components, the OOP components, and the generic components to learn C++, but at least you may not have to unlearn programming habits. If you are beginning to think that learning C++ may involve some mind-stretching effort on your part, you’re right.This book will guide you through the process in a clear, helpful manner, one step at a time, so the mind-stretching will be sufficiently gentle to leave your brain resilient. C++ Primer Plus approaches C++ by teaching both its C basis and its new components, so it assumes that you have no prior knowledge of C.You’ll start by learning the features C++ shares with C. Even if you know C, you may find this part of the book a good review.Also it points out concepts that will become important later, and it indicates where C++ differs from C.After you have a good grounding in the basics of C, you’ll learn about the C++ superstructure.At that point, you’ll learn about objects and classes and how C++ implements them.And you will learn about templates. This book is not intended to be a complete C++ reference; it doesn’t explore every nook and cranny of the language. But you will learn most of the major features of the language, including templates, exceptions, and namespaces. Now let’s take a brief look at some of C++’s background.
The Origins of C++: A Little History
Computer technology has evolved at an amazing rate over the past few decades.Today a notebook computer can compute faster and store more information than the mainframe computers of the 1960s. (Quite a few programmers can recall bearing offerings of decks of punched cards to be submitted to a mighty, room-filling computer system with a majestic 100KB of memory—far less memory than even a smartphone uses today.) Computer languages have evolved, too.The changes may not be as dramatic, but they are important. Bigger, more powerful computers spawn bigger, more complex programs, which, in turn, raise new problems in program management and maintenance. In the 1970s, languages such as C and Pascal helped usher in an era of structured programming, a philosophy that brought some order and discipline to a field badly in need of these qualities. Besides providing the tools for structured programming, C also


11
The Origins of C++: A Little History
produced compact, fast-running programs, along with the ability to address hardware matters, such as managing communication ports and disk drives.These gifts helped make C the dominant programming language in the 1980s. Meanwhile, the 1980s witnessed the growth of a new programming paradigm: object-oriented programming, or OOP, as embodied in languages such as SmallTalk and C++. Let’s examine these C and OOP a bit more closely.
The C Language
In the early 1970s, Dennis Ritchie of Bell Laboratories was working on a project to develop the Unix operating system. (An operating system is a set of programs that manages a computer’s resources and handles its interactions with users. For example, it’s the operating system that puts the system prompt onscreen for a terminal-style interface that manages the windows and mice for graphical interfaces and that runs programs for you.) For this work Ritchie needed a language that was concise, that produced compact, fast programs, and that could control hardware efficiently. Traditionally, programmers met these needs by using assembly language, which is closely tied to a computer’s internal machine language. However, assembly language is a low-level language—that is, it works directly with the hardware (for instance, accessing CPU registers and memory locations directly).Thus, assembly language is specific to a particular computer processor. So if you want to move an assembly program to a different kind of computer, you may have to completely rewrite the program, using a different assembly language. It was a bit as if each time you bought a new car, you found that the designers decided to change where the controls went and what they did, forcing you to relearn how to drive. But Unix was intended to work on a variety of computer types (or platforms).That suggested using a high-level language.A high-level language is oriented toward problem solving instead of toward specific hardware. Special programs called compilers translate a high-level language to the internal language of a particular computer.Thus, you can use the same high-level language program on different platforms by using a separate compiler for each platform. Ritchie wanted a language that combined low-level efficiency and hardware access with high-level generality and portability. So building from older languages, he created C.
C Programming Philosophy
Because C++ grafts a new programming philosophy onto C, we should first take a look at the older philosophy that C follows. In general, computer languages deal with two concepts—data and algorithms.The data constitutes the information a program uses and processes.The algorithms are the methods the program uses (see Figure 1.1). Like most mainstream languages when C was created, C is a procedural language.That means it emphasizes the algorithm side of programming. Conceptually, procedural programming


12 Chapter 1 Getting Started with C++
PROGRAM
DATA
1/2 cup butter
1 cup sugar
2 eggs ...
ALGORITHMS
cream butter
gradually, add sugar
break eggs ...
+
Figure 1.1 Data + algorithms = program.
consists of figuring out the actions a computer should take and then using the programming language to implement those actions. A program prescribes a set of procedures for the computer to follow to produce a particular outcome, much as a recipe prescribes a set of procedures for a cook to follow to produce a cake.
Earlier procedural languages, such as FORTRAN and BASIC, ran into organizational problems as programs grew larger. For example, programs often use branching statements, which route execution to one or another set of instructions, depending on the result of some sort of test. Many older programs had such tangled routing (called “spaghetti programming”) that it was virtually impossible to understand a program by reading it, and modifying such a program was an invitation to disaster. In response, computer scientists developed a more disciplined style of programming called structured programming. C includes features to facilitate this approach. For example, structured programming limits branching (choosing which instruction to do next) to a small set of well-behaved constructions. C incorporates these constructions (the for loop, the while loop, the do while loop, and the if else statement) into its vocabulary. Top-down design was another of the new principles.With C, the idea is to break a large program into smaller, more manageable tasks. If one of these tasks is still too broad, you divide it into yet smaller tasks.You continue with this process until the program is compartmentalized into small, easily programmed modules. (Organize your study.Aargh! Well, organize your desk, your table top, your filing cabinet, and your bookshelves.Aargh! Well, start with the desk and organize each drawer, starting with the middle one. Hmmm, perhaps I can manage that task.) C’s design facilitates this approach, encouraging you to


13
The Origins of C++: A Little History
develop program units called functions to represent individual task modules.As you may have noticed, the structured programming techniques reflect a procedural mind-set, thinking of a program in terms of the actions it performs.
The C++ Shift: Object-Oriented Programming
Although the principles of structured programming improved the clarity, reliability, and ease of maintenance of programs, large-scale programming still remains a challenge. OOP brings a new approach to that challenge. Unlike procedural programming, which emphasizes algorithms, OOP emphasizes the data. Rather than try to fit a problem to the procedural approach of a language, OOP attempts to fit the language to the problem.The idea is to design data forms that correspond to the essential features of a problem. In C++, a class is a specification describing such a new data form, and an object is a particular data structure constructed according to that plan. For example, a class could describe the general properties of a corporation executive (name, title, salary, unusual abilities, for example), while an object would represent a specific executive (Guilford Sheepblat, vice president, $925,000, knows how to restore the Windows registry). In general, a class defines what data is used to represent an object and the operations that can be performed on that data. For example, suppose you were developing a computer drawing program capable of drawing a rectangle.You could define a class to describe a rectangle.The data part of the specification could include such things as the location of the corners, the height and width, the color and style of the boundary line, and the color and pattern used to fill the rectangle.The operations part of the specification could include methods for moving the rectangle, resizing it, rotating it, changing colors and patterns, and copying the rectangle to another location. If you then used your program to draw a rectangle, it would create an object according to the class specification.That object would hold all the data values describing the rectangle, and you could use the class methods to modify that rectangle. If you drew two rectangles, the program would create two objects, one for each rectangle. The OOP approach to program design is to first design classes that accurately represent those things with which the program deals. For example, a drawing program might define classes to represent rectangles, lines, circles, brushes, pens, and the like.The class definitions, recall, include a description of permissible operations for each class, such as moving a circle or rotating a line.Then you would proceed to design a program, using objects of those classes.The process of going from a lower level of organization, such as classes, to a higher level, such as program design, is called bottom-up programming. There’s more to OOP than the binding of data and methods into a class definition. For example, OOP facilitates creating reusable code, and that can eventually save a lot of work. Information hiding safeguards data from improper access. Polymorphism lets you create multiple definitions for operators and functions, with the programming context determining which definition is used. Inheritance lets you derive new classes from old ones.As you can see, OOP introduces many new ideas and involves a different approach to programming than does procedural programming. Instead of concentrating on tasks,


14 Chapter 1 Getting Started with C++
you concentrate on representing concepts. Instead of taking a top-down programming approach, you sometimes take a bottom-up approach.This book will guide you through all these points, with plenty of easily grasped examples. Designing a useful, reliable class can be a difficult task. Fortunately, OOP languages make it simple to incorporate existing classes into your own programming.Vendors provide a variety of useful class libraries, including libraries of classes designed to simplify creating programs for environments such as Windows or the Macintosh. One of the real benefits of C++ is that it lets you easily reuse and adapt existing, well-tested code.
C++ and Generic Programming
Generic programming is yet another programming paradigm supported by C++. It shares with OOP the aim of making it simpler to reuse code and the technique of abstracting general concepts. But whereas OOP emphasizes the data aspect of programming, generic programming emphasizes independence from a particular data type.And its focus is different. OOP is a tool for managing large projects, whereas generic programming provides tools for performing common tasks, such as sorting data or merging lists.The term generic refers to code that is type independent. C++ data representations come in many typesintegers, numbers with fractional parts, characters, strings of characters, and user-defined compound structures of several types. If, for example, you wanted to sort data of these various types, you would normally have to create a separate sorting function for each type. Generic programming involves extending the language so that you can write a function for a generic (that is, an unspecified) type once and use it for a variety of actual types. C++ templates provide a mechanism for doing that.
The Genesis of C++
Like C, C++ began its life at Bell Labs, where Bjarne Stroustrup developed the language in the early 1980s. In Stroustrup’s own words,“C++ was designed primarily so that my friends and I would not have to program in assembler, C, or various modern high-level languages. Its main purpose was to make writing good programs easier and more pleasant for the individual programmer” (Bjarne Stroustrup, The C++ Programming Language,Third Edition. Reading, MA:Addison-Wesley, 1997).
Bjarne Stroustrup’s Home Page
Bjarne Stroustrup designed and implemented the C++ programming language and is the author of the definitive reference manuals The C++ Programming Language and The Design and Evolution of C++. His personal website at AT&T Labs Research should be the first C++ bookmark, or favorite, you create:
www.research.att.com/~bs
This site includes an interesting historical perspective of the hows and whys of the C++ language, Stroustrup’s biographical material, and C++ FAQs. Surprisingly, Stroustrup’s most frequently asked question may be how to pronounce Bjarne Stroustrup. Check out the FAQ on Stroustrup’s website and download the .WAV file to hear for yourself!


15
Portability and Standards
Stroustrup was more concerned with making C++ useful than with enforcing particular programming philosophies or styles. Real programming needs are more important than theoretical purity in determining C++ language features. Stroustrup based C++ on C because of C’s brevity, its suitability to system programming, its widespread availability, and its close ties to the Unix operating system. C++’s OOP aspect was inspired by a computer simulation language called Simula67. Stroustrup added OOP features and generic programming support to C without significantly changing the C component.Thus C++ is a superset of C, meaning that any valid C program is a valid C++ program, too.There are some minor discrepancies but nothing crucial. C++ programs can use existing C software libraries. Libraries are collections of programming modules that you can call up from a program.They provide proven solutions to many common programming problems, thus saving you much time and effort.This has helped the spread of C++. The name C++ comes from the C increment operator ++, which adds one to the value of a variable.Therefore, the name C++ correctly suggests an augmented version of C. A computer program translates a real-life problem into a series of actions to be taken by a computer.The OOP aspect of C++ gives the language the ability to relate to concepts involved in the problem, and the C part of C++ gives the language the ability to get close to the hardware (see Figure 1.2).This combination of abilities has enabled the spread of C++. It may also involve a mental shift of gears as you turn from one aspect of a program to another. (Indeed, some OOP purists regard adding OOP features to C as being akin to adding wings to a pig, albeit a lean, efficient pig.) Also because C++ grafts OOP onto C, you can ignore C++’s object-oriented features. But you’ll miss a lot if that’s all you do. Only after C++ achieved some success did Stroustrup add templates, enabling generic programming.And only after the template feature had been used and enhanced did it become apparent that templates were perhaps as significant an addition as OOP—or even more significant, some would argue.The fact that C++ incorporates both OOP and generic programming, as well as the more traditional procedural approach, demonstrates that C++ emphasizes the utilitarian over the ideological approach, and that is one of the reasons for the language’s success.
Portability and Standards
Say you’ve written a handy C++ program for the elderly Pentium PC computer running Windows 2000 at work, but management decides to replace the machine with a new computer using a different operating system, say Mac OS X or Linux, perhaps one with a different processor design, such as a SPARC processor. Can you run your program on the new platform? Of course you’ll have to recompile the program using a C++ compiler designed for the new platform. But will you have to make any changes to the code you wrote? If you can recompile the program without making changes and it runs without a hitch, we say the program is portable.


16 Chapter 1 Getting Started with C++
C heritage provides low-level hardware access.
OOP heritage provides a high level of abstraction.
.... north_america.show(); ....
set byte at address 01000 to 0
Figure 1.2 C++ duality.
There are a couple obstacles to portability, the first of which is hardware.A program that is hardware specific is not likely to be portable. One that takes direct control of an IBM PC video board, for example, speaks gibberish as far as, say, a Sun is concerned. (You can minimize portability problems by localizing the hardware-dependent parts in function modules; then you just have to rewrite those specific modules.) We avoid that sort of programming in this book. The second obstacle to portability is language divergence. Certainly, that can be a problem with spoken languages.A Yorkshireman’s description of the day’s events may not be portable to Brooklyn, even though English is said to be spoken in both areas. Computer languages, too, can develop dialects.Although most implementers would like to make their versions of C++ compatible with others, it’s difficult to do so without a published standard describing exactly how the language works.Therefore, the American National Standards Institute (ANSI) created a committee in 1990 (ANSI X3J16) to develop a standard for C++. (ANSI had already developed a standard for C.) The International Organization for Standardization (ISO) soon joined the process with its own committee (ISO-WG-21), creating a joint ANSI/ISO effort to develop the standard for C++.


17
Portability and Standards
Several years of work eventually led to the International Standard (ISO/IEC 14882:1998), which was adopted in 1998 by the ISO, the International Electrotechnical Commission (IEC), and ANSI.This standard, often called C++98, not only refined the description of existing C++ features but also extended the language with exceptions, runtime type identification (RTTI), templates, and the Standard Template Library (STL).The year 2003 brought the publication of the second edition of the C++ standard (ISO/IEC 14882:2003); the new edition is a technical revision, meaning that it tidies up the first edition—fixing typos, reducing ambiguities, and the like—but doesn’t change the language features.This edition often is called C++03. Because C++03 didn’t change language features, we’ll follow a common usage and use C++98 to refer to C++98/C++03. C++ continues to evolve, and the ISO committee approved a new standard August 2011 titled ISO/IEC 14882:2011 and informally dubbed C++11. Like C++98, C++11 adds many features to the language. In addition, it has the goals of removing inconsistencies and of making C++ easier to learn and use.This standard had been dubbed C++0x, with the original expectation that x would be 7 or 8, but standards work is a slow, exhaustive, and exhausting process. Fortunately, it was soon realized that 0x could be a hexadecimal integer (see Appendix A,“Number Bases”), which meant the committee had until 2015 to finish the work. So by that measure, they have finished ahead of schedule. The ISO C++ Standard additionally draws on the ANSI C Standard because C++ is supposed to be, as far as possible, a superset of C.That means that any valid C program ideally should also be a valid C++ program.There are a few differences between ANSI C and the corresponding rules for C++, but they are minor. Indeed,ANSI C incorporates some features first introduced in C++, such as function prototyping and the const type qualifier. Prior to the emergence of ANSI C, the C community followed a de facto standard based on the book The C Programming Language, by Kernighan and Ritchie (Addison-Wesley Publishing Company, Reading, MA, 1978).This standard was often termed K&R C; with the emergence of ANSI C, the simpler K&R C is now sometimes called classic C. The ANSI C Standard not only defines the C language, it also defines a standard C library that ANSI C implementations must support. C++ also uses that library; this book refers to it as the standard C library or the standard library. In addition, the ISO C++ standard provides a standard library of C++ classes. The C Standard was last revised as C99, which was adopted by the ISO in 1999 and ANSI in 2000.This standard adds some features to C, such as a new integer type, that some C++ compilers support.
Language Growth
Originally, the de facto standard for C++ was a 65-page reference manual included in the 328-page The C++ Programming Language, by Stroustrup (Addison-Wesley, 1986). The next major published de facto standard was The Annotated C++ Reference Manual, by Ellis and Stroustrup (Addison-Wesley, 1990).This is a 453-page work; it includes substantial commentary in addition to reference material.


18 Chapter 1 Getting Started with C++
The C++98 standard, with the addition of many features, reached nearly 800 pages, even with only minimal commentary. The C++11 standard is over 1,350 pages long, so it augments the old standard substantially .
This Book and C++ Standards
Contemporary compilers provide good support for C++98. Some compilers at the time of this writing also support some C++11 features, and we can expect the level of support to increase quickly now that the new standard is adopted.This book reflects the current situation, covering C++98 pretty thoroughly and introducing several C++11 features. Some of these features are integrated with the coverage of related C++98 topics. Chapter 18,“Visiting with the New C++ Standard,” concentrates on the new features, summarizing the ones mentioned earlier in the book and presenting additional features. With the incomplete support available at the time of this writing, it would be very difficult to cover adequately all the new C++11 features. But even when the new standard is completely supported, it’s clear that comprehensive coverage would be beyond the scope of any reasonably sized single volume book.This book takes the approach of concentrating on features that are already available on some compilers and briefly summarizing many of the other features. Before getting to the C++ language proper, let’s cover some of the groundwork related to creating programs.
The Mechanics of Creating a Program
Suppose you’ve written a C++ program. How do you get it running? The exact steps depend on your computer environment and the particular C++ compiler you use, but they should resemble the following steps (see Figure 1.3):
1. Use a text editor of some sort to write the program and save it in a file.This file constitutes the source code for your program.
2. Compile the source code.This means running a program that translates the source code to the internal language, called machine language, used by the host computer. The file containing the translated program is the object code for your program.
3. Link the object code with additional code. For example, C++ programs normally use libraries.A C++ library contains object code for a collection of computer routines, called functions, to perform tasks such as displaying information onscreen or calculating the square root of a number. Linking combines your object code with object code for the functions you use and with some standard startup code to produce a runtime version of your program.The file containing this final product is called the executable code.
You will encounter the term source code throughout this book, so be sure to file it away in your personal random-access memory.


19
The Mechanics of Creating a Program
executable code
source code
COMPILER
object code
LINKER
startup code
library code
Figure 1.3 Programming steps.
Most of the programs in this book are generic and should run in any system that supports C++98. However, some, particularly those in Chapter 18, do require some C++11 support.At the time of this writing, some compilers require additional flags to activate their partial C++11 support. For instance, g++, beginning with version 4.3, currently uses the –std=c++0x flag when compiling a source code file:
g++ -std=c++0x use_auto.cpp
The steps for putting together a program may vary. Let’s look a little further at these steps.
Creating the Source Code File
The rest of the book deals with what goes into a source file; this section discusses the mechanics of creating one. Some C++ implementations, such as Microsoft Visual C++, Embarcadero C++ Builder,Apple Xcode, Open Watcom C++, Digital Mars C++, and Freescale CodeWarrior, provide integrated development environments (IDEs) that let you manage all steps of program development, including editing, from one master program. Other implementations, such as GNU C++ on Unix and Linux, IBM XL C/C++ on AIX, and the free versions of the Borland 5.5 (distributed by Embarcadero) and Digital Mars compilers, just handle the compilation and linking stages and expect you to type commands on the system command line. In such cases, you can use any available text editor to create and modify source code. On a Unix system, for example, you can use vi or ed or ex or emacs. On a Windows system running in the Command Prompt mode you can use edlin


20 Chapter 1 Getting Started with C++
a period
spiffy.cpp
base name for file file name extension
Figure 1.4 The parts of a source code filename.
Table 1.1 Source Code Extensions
C++ Implementation Source Code Extension(s)
Unix C, cc, cxx, c
GNU C++ C, cc, cxx, cpp, c++
Digital Mars cpp, cxx
Borland C++ cpp
Watcom cpp
Microsoft Visual C++ cpp, cxx, cc
Freestyle CodeWarrior cpp, cp, cc, cxx, c++
or edit or any of several available program editors.You can even use a word processor, provided that you save the file as a standard ASCII text file instead of in a special word processor format.Alternatively, there may be IDE options for use with these commandline compilers. In naming a source file, you must use the proper suffix to identify the file as a C++ file.This not only tells you that the file is C++ source code, it tells the compiler that, too. (If a Unix compiler complains to you about a “bad magic number,” that’s just its endearingly obscure way of saying that you used the wrong suffix.) The suffix consists of a period followed by a character or group of characters called the extension (see Figure 1.4).
The extension you use depends on the C++ implementation.Table 1.1 shows some common choices. For example, spiffy.C is a valid Unix C++ source code filename. Note that Unix is case sensitive, meaning you should use an uppercase C character.Actually, a lowercase c extension also works, but standard C uses that extension. So to avoid confusion on Unix systems, you should use c with C programs and C with C++ programs. If you don’t mind typing an extra character or two, you can also use the cc and cxx extensions with some Unix systems. DOS, being a bit simple-minded compared to Unix, doesn’t distinguish between uppercase and lowercase, so DOS implementations use additional letters, as shown in Table 1.1, to distinguish between C and C++ programs.


21
The Mechanics of Creating a Program
Compilation and Linking
Originally, Stroustrup implemented C++ with a C++-to-C compiler program instead of developing a direct C++-to-object code compiler.This program, called cfront (for C front end), translated C++ source code to C source code, which could then be compiled by a standard C compiler.This approach simplified introducing C++ to the C community. Other implementations have used this approach to bring C++ to other platforms.As C++ has developed and grown in popularity, more and more implementers have turned to creating C++ compilers that generate object code directly from C++ source code.This direct approach speeds up the compilation process and emphasizes that C++ is a separate, if similar, language. The mechanics of compiling depend on the implementation, and the following sections outline a few common forms.These sections outline the basic steps, but they are no substitute for consulting the documentation for your system.
Unix Compiling and Linking
Originally, the Unix CC command invoked cfront. However, cfront didn’t keep pace with the evolution of C++, and its last release was in 1993.These days a Unix computer instead might have no compiler, a proprietary compiler, or a third-party compiler, perhaps commercial, perhaps freeware, such as the GNU g++ compiler. In many of these other cases (but not in the no-compiler case!), the CC command still works, with the actual compiler being invoked differing from system to system. For simplicity, we’ll assume that CC is available, but realize that you might have to substitute a different command for CC in the following discussion. You use the CC command to compile your program.The name is in uppercase letters to distinguish it from the standard Unix C compiler cc.The CC compiler is a command-line compiler, meaning you type compilation commands on the Unix command line. For example, to compile the C++ source code file spiffy.C, you would type this command at the Unix prompt:
CC spiffy.C
If, through skill, dedication, or luck, your program has no errors, the compiler generates an object code file with an o extension. In this case, the compiler produces a file named
spiffy.o.
Next, the compiler automatically passes the object code file to the system linker, a program that combines your code with library code to produce the executable file. By default, the executable file is called a.out. If you used just one source file, the linker also deletes the spiffy.o file because it’s no longer needed.To run the program, you just type the name of the executable file:
a.out
Note that if you compile a new program, the new a.out executable file replaces the previous a.out. (That’s because executable files take a lot of space, so overwriting old executable files helps reduce storage demands.) But if you develop an executable program


22 Chapter 1 Getting Started with C++
you want to keep, you just use the Unix mv command to change the name of the executable file. In C++, as in C, you can spread a program over more than one file. (Many of the programs in this book in Chapters 8 through 16 do this.) In such a case, you can compile a program by listing all the files on the command line, like this:
CC my.C precious.C
If there are multiple source code files, the compiler does not delete the object code files.That way, if you just change the my.C file, you can recompile the program with this command:
CC my.C precious.o
This recompiles the my.C file and links it with the previously compiled precious.o file. You might have to identify some libraries explicitly. For example, to access functions defined in the math library, you may have to add the -lm flag to the command line:
CC usingmath.C -lm
Linux Compiling and Linking
Linux systems most commonly use g++, the GNU C++ compiler from the Free Software Foundation.The compiler is included in most Linux distributions, but it may not always be installed.The g++ compiler works much like the standard Unix compiler. For example, the following produces an executable file call a.out:
g++ spiffy.cxx
Some versions might require that you link in the C++ library:
g++ spiffy.cxx -lg++
To compile multiple source files, you just list them all in the command line:
g++ my.cxx precious.cxx
This produces an executable file called a.out and two object code files, my.o and precious.o. If you subsequently modify just one of the source code files, say my.cxx, you can recompile by using my.cxx and the precious.o:
g++ my.cxx precious.o
The GNU compiler is available for many platforms, including the command-line mode for Windows-based PCs as well as for Unix systems on a variety of platforms.
Command-Line Compilers for Windows Command Prompt Mode
An inexpensive route for compiling C++ programs on a Windows PC is to download a free command-line compiler that runs in Windows Command Prompt mode, which opens an MS-DOS-like window. Free Windows downloads that include the GNU C++ compiler are Cygwin and MinGW; they use g++ as the compiler name.


23
The Mechanics of Creating a Program
To use the g++ compiler, you first open a command prompt window. Cygwin and MinGW do this for you automatically when you start those programs.To compile a source code file named great.cpp, you type the following command at the prompt:
g++ great.cpp
If the program compiles successfully, the resultant executable file is named a.exe.
Windows Compilers
Windows products are too abundant and too often revised to make it reasonable to describe them all individually.At the present the most popular is Microsoft Visual C++ 2010, which is available in the free Microsoft Visual C++ 2010 Express edition.The Wikipedia link (http://en.wikipedia.org/wiki/List_of_compilers) provides a comprehensive list of compilers for many platforms, including Windows. Despite different designs and goals, most Windows-based C++ compilers share some common features. Typically, you must create a project for a program and add to the project the file or files constituting the program. Each vendor supplies an IDE with menu options and, possibly, automated assistance, in creating a project. One very important matter you have to establish is the kind of program you’re creating.Typically, the compiler offers many choices, such as a Windows application, an MFC Windows application, a dynamic link library, an ActiveX control, a DOS or character-mode executable, a static library, or a console application. Some of these may be available in both 64-bit and 32-bit versions. Because the programs in this book are generic, you should avoid choices that require platform-specific code, such as Windows applications. Instead, you want to run in a character-based mode.The choice depends on the compiler. In general, you should look to see if there is an option labeled Console, character-mode, or DOS executable and try that. For instance, in Microsoft Visual C++ 2010, select the Win32 Console Application option, click Application Settings, and select the Empty Project option. In C++Builder XE, select Console Application under C++Builder Projects. After you have the project set up, you have to compile and link your program.The IDE typically gives you several choices, such as Compile, Build, Make, Build All, Link, Execute, Run, and Debug (but not necessarily all these choices in the same IDE!):
n Compile typically means compile the code in the file that is currently open.
n Build or Make typically means compile the code for all the source code files in the project.This is often an incremental process.That is, if the project has three files, and you change just one, and then just that one is recompiled.
n Build All typically means compile all the source code files from scratch.
n As described earlier, Link means combine the compiled source code with the necessary library code.
n Run or Execute means run the program.Typically, if you have not yet done the earlier steps, Run does them before trying to run a program.
n Debug means run the program with the option of going through step-by-step.


24 Chapter 1 Getting Started with C++
n A compiler may offer the option of Debug and Release versions.The former contains extra code that increases the program size, slows program execution, but enables detailed debugging features.
A compiler generates an error message when you violate a language rule and identifies the line that has the problem. Unfortunately, when you are new to a language, you may find it difficult to understand the message. Sometimes the actual error may occur before the identified line, and sometimes a single error generates a chain of error messages.
Tip
When fixing errors, fix the first error first. If you can’t find it on the line identified as the line with the error, check the preceding line.
Be aware of the fact that a particular compiler accepts a program doesn’t necessarily mean that the program is valid C++.And the fact that a particular compiler rejects a program doesn’t necessarily mean that the program is invalid C++. However, current compilers are more compliant with the Standard than their predecessors of a few years ago.Also compilers typically have options to control how strict the compiler is.
Tip
Occasionally, compilers get confused after incompletely building a program and respond by giving meaningless error messages that cannot be fixed. In such cases, you can clear things up by selecting Build All to restart the process from scratch. Unfortunately, it is difficult to distinguish this situation from the more common one in which the error messages merely seem to be meaningless.
Usually, the IDE lets you run the program in an auxiliary window. Some IDEs close the window as soon as the program finishes execution, and some leave it open. If your compiler closes the window, you’ll have a hard time seeing the output unless you have quick eyes and a photographic memory.To see the output, you must place some additional code at the end of the program:
cin.get(); // add this statement
cin.get(); // and maybe this, too
return 0;
}
The cin.get() statement reads the next keystroke, so this statement causes the program to wait until you press the Enter key. (No keystrokes get sent to a program until you press Enter, so there’s no point in pressing another key.) The second statement is needed if the program otherwise leaves an unprocessed keystroke after its regular input. For example, if you enter a number, you type the number and then press Enter.The program reads the number but leaves the Enter keystroke unprocessed, and it is then read by the first
cin.get().


25
Summary
C++ on the Macintosh
Apple currently supplies a developer framework called Xcode with the Mac OS X operating system. It’s free but normally not preinstalled.You can install it from the operating system installation disks, or you can download it for a nominal fee from Apple. (Be aware that it is over a 4GB download.) Not only does it provide an IDE that supports several programming languages, it also installs a couple of compilers—g++ and clang—that can be used as command-line programs in the Unix mode accessible through the Terminal utility.
Tip
For IDEs: To save time, you can use just one project for all the sample programs. Just delete the previous sample source code file from the project list and add the current source code. This saves time, effort, and lessens disk clutter.
Summary
As computers have grown more powerful, computer programs have become larger and more complex. In response to these conditions, computer languages have evolved so that it’s easier to manage the programming process.The C language incorporated features such as control structures and functions to better control the flow of a program and to enable a more structured, modular approach.To these tools C++ adds support for object-oriented programming and generic programming.This enables even more modularity and facilitates the creation of reusable code, which saves time and increases program reliability. The popularity of C++ has resulted in a large number of implementations for many computing platforms; the C++ ISO standards (C++98/03 and C++11) provide a basis for keeping these many implementations mutually compatible.The standards establishes the features the language should have, the behavior the language should display, and a standard library of functions, classes, and templates.The standards supports the goal of a portable language across different computing platforms and different implementations of the language. To create a C++ program, you create one or more source files containing the program as expressed in the C++ language.These are text files that must be compiled and linked to produce the machine-language files that constitute executable programs.These tasks are often accomplished in an IDE that provides a text editor for creating the source files, a compiler and a linker for producing executable files, and other resources, such as project management and debugging capabilities. But the same tasks can also be performed in a command-line environment by invoking the appropriate tools individually.


This page intentionally left blank


2
Setting Out to C++
I
n this chapter you’ll learn about the following:
n Creating a C++ program
n The general format for a C++ program
n The #include directive
n The main() function
n Using the cout object for output
n Placing comments in a C++ program
n How and when to use endl
n Declaring and using variables
n Using the cin object for input
n Defining and using simple functions
When you construct a simple home, you begin with the foundation and the framework. If you don’t have a solid structure from the beginning, you’ll have trouble later filling in the details, such as windows, door frames, observatory domes, and parquet ballrooms. Similarly, when you learn a computer language, you should begin by learning the basic structure for a program. Only then can you move on to the details, such as loops and objects.This chapter gives you an overview of the essential structure of a C++ program and previews some topics—notably functions and classes—covered in much greater detail in later chapters. (The idea is to introduce at least some of the basic concepts gradually en route to the great awakenings that come later.)
C++ Initiation
Let’s begin with a simple C++ program that displays a message. Listing 2.1 uses the C++ cout (pronounced “see-out”) facility to produce character output.The source code includes several comments to the reader; these lines begin with //, and the compiler ignores them. C++ is case sensitive; that is, it discriminates between uppercase characters


28 Chapter 2 Setting Out to C++
and lowercase characters.This means you must be careful to use the same case as in the examples. For example, this program uses cout, and if you substitute Cout or COUT, the compiler rejects your offering and accuses you of using unknown identifiers. (The compiler is also spelling sensitive, so don’t try kout or coot, either.) The cpp filename extension is a common way to indicate a C++ program; you might need to use a different extension, as described in Chapter 1,“Getting Started with C++.”
Listing 2.1 myfirst.cpp
// myfirst.cpp -- displays a message
#include <iostream> // a PREPROCESSOR directive
int main() // function header
{ // start of function body
using namespace std; // make definitions visible
cout << "Come up and C++ me some time."; // message
cout << endl; // start a new line
cout << "You won’t regret it!" << endl; // more output
return 0; // terminate main()
} // end of function body
Program Adjustments
You might find that you must alter the examples in this book to run on your system. The most common reason is a matter of the programming environment. Some windowing environments run the program in a separate window and then automatically close the window when the program finishes. As discussed in Chapter 1, you can make the window stay open until you strike a key by adding the following line of code before the return statement:
cin.get();
For some programs you must add two of these lines to keep the window open until you press a key. You’ll learn more about cin.get() in Chapter 4, “Compound Types.”
If you have a very old system, it may not support features introduced by the C++98 standard.
Some programs require a compiler with some level of support for the C++11 standard. They will be clearly identified and, if possible, alternative non-C++11 code will be suggested.
After you use your editor of choice to copy this program (or else use the source code files available online from this book’s web page—check the registration link on the back cover for more information), you can use your C++ compiler to create the executable code, as Chapter 1 outlines. Here is the output from running the compiled program in Listing 2.1:
Come up and C++ me some time.
You won’t regret it!


29
C++ Initiation
C Input and Output
If you’re used to programming in C, seeing cout instead of the printf() function might come as a minor shock. C++ can, in fact, use printf(), scanf(), and all the other standard C input and output functions, provided that you include the usual C stdio.h file. But this is a C++ book, so it uses C++’s input facilities, which improve in many ways upon the C versions.
You construct C++ programs from building blocks called functions.Typically, you organize a program into major tasks and then design separate functions to handle those tasks.The example shown in Listing 2.1 is simple enough to consist of a single function named main().The myfirst.cpp example has the following elements:
n Comments, indicated by the // prefix
n A preprocessor #include directive
n A function header: int main()
n A using namespace directive
n A function body, delimited by { and }
n Statements that uses the C++ cout facility to display a message
n A return statement to terminate the main() function
Let’s look at these various elements in greater detail.The main() function is a good place to start because some of the features that precede main(), such as the preprocessor directive, are simpler to understand after you see what main() does.
Features of the main() Function
Stripped of the trimmings, the sample program shown in Listing 2.1 has the following fundamental structure:
int main()
{
statements
return 0;
}
These lines state that there is a function called main(), and they describe how the function behaves.Together they constitute a function definition.This definition has two parts: the first line, int main(), which is called the function header, and the portion enclosed in braces ({ and }), which is the function body. (A quick search on the Web reveals braces also go by other names, including “curly brackets,”“flower brackets,”“fancy brackets,” and “chicken lips.” However, the ISO Standard uses the term “braces.”) Figure 2.1 shows the main() function.The function header is a capsule summary of the function’s interface with the rest of the program, and the function body represents instructions to the computer about what the function should do. In C++ each complete instruction is called a statement.You must terminate each statement with a semicolon, so don’t omit the semicolons when you type the examples.


30 Chapter 2 Setting Out to C++
The final statement in main(), called a return statement, terminates the function.You’ll learn more about the return statement as you read through this chapter.
Statements and Semicolons
A statement represents an action to be taken. To understand your source code, a compiler needs to know when one statement ends and another begins. Some languages use a statement separator. FORTRAN, for example, uses the end of the line to separate one statement from the next. Pascal uses a semicolon to separate one statement from the next. In Pascal you can omit the semicolon in certain cases, such as after a statement just before an END, when you aren’t actually separating two statements. (Pragmatists and minimalists will disagree about whether can implies should.) But C++, like C, uses a semicolon as a terminator rather than as a separator. The difference is that a semicolon acting as a terminator is part of the statement rather than a marker between statements. The practical upshot is that in C++ you should never omit the semicolon.
The Function Header as an Interface
Right now the main point to remember is that C++ syntax requires you to begin the definition of the main() function with this header: int main().This chapter discusses the function header syntax in more detail later, in the section “Functions,” but for those who can’t put their curiosity on hold, here’s a preview. In general, a C++ function is activated, or called, by another function, and the function header describes the interface between a function and the function that calls it.The part preceding the function name is called the function return type; it describes information flow from a function back to the function that calls it.The part within the parentheses following the function name is called the argument list or parameter list; it describes information flow from the calling function to the called function.This general description is a bit confusing when you apply it to main() because you normally don’t call main() from other parts of your program.Typically, however, main() is called by startup code that the compiler adds to your program to mediate between the program and the operating system
function name
terminates function
Statements are C++ expressions terminated by a semicolon.
function header
function body
function definition
int main()
{
statements
return 0;
}
Figure 2.1 The main() function.


31
C++ Initiation
(Unix,Windows 7, Linux, or whatever). In effect, the function header describes the interface between main() and the operating system. Consider the interface description for main(), beginning with the int part. A C++ function called by another function can return a value to the activating (calling) function. That value is called a return value. In this case, main() can return an integer value, as indicated by the keyword int. Next, note the empty parentheses. In general, a C++ function can pass information to another function when it calls that function.The portion of the function header enclosed in parentheses describes that information. In this case, the empty parentheses mean that the main() function takes no information, or in the usual terminology, main() takes no arguments. (To say that main() takes no arguments doesn’t mean that main() is an unreasonable, authoritarian function. Instead, argument is the term computer buffs use to refer to information passed from one function to another.) In short, the following function header states that the main() function returns an integer value to the function that calls it and that main() takes no information from the function that calls it:
int main()
Many existing programs use the classic C function header instead:
main() // original C style
Under classic C, omitting the return type is the same as saying that the function is type int. However, C++ has phased out that usage. You can also use this variant:
int main(void) // very explicit style
Using the keyword void in the parentheses is an explicit way of saying that the function takes no arguments. Under C++ (but not C), leaving the parentheses empty is the same as using void in the parentheses. (In C, leaving the parentheses empty means you are remaining silent about whether there are arguments.) Some programmers use this header and omit the return statement:
void main()
This is logically consistent because a void return type means the function doesn’t return a value. However, although this variant works on some systems, it’s not part of the C++ Standard.Thus, on other systems it fails. So you should avoid this form and use the C++ Standard form; it doesn’t require that much more effort to do it right. Finally, the ISO C++ Standard makes a concession to those who complain about the tiresome necessity of having to place a return statement at the end of main(). If the compiler reaches the end of main() without encountering a return statement, the effect will be the same as if you ended main() with this statement:
return 0;
This implicit return is provided only for main() and not for any other function.


32 Chapter 2 Setting Out to C++
Why main() by Any Other Name Is Not the Same
There’s an extremely compelling reason to name the function in the myfirst.cpp program main():You must do so. Ordinarily, a C++ program requires a function called main(). (And not, by the way, Main() or MAIN() or mane(). Remember, case and spelling count.) Because the myfirst.cpp program has only one function, that function must bear the responsibility of being main().When you run a C++ program, execution always begins at the beginning of the main() function.Therefore, if you don’t have main(), you don’t have a complete program, and the compiler points out that you haven’t defined a main() function. There are exceptions. For example, in Windows programming you can write a dynamic link library (DLL) module.This is code that other Windows programs can use. Because a DLL module is not a standalone program, it doesn’t need a main(). Programs for specialized environments, such as for a controller chip in a robot, might not need a main(). Some programming environments provide a skeleton program calling some nonstandard function, such as _tmain(); in that case there is a hidden main() that calls _tmain(). But your ordinary standalone program does need a main(); this books discusses that sort of program.
C++ Comments
The double slash (//) introduces a C++ comment.A comment is a remark from the programmer to the reader that usually identifies a section of a program or explains some aspect of the code.The compiler ignores comments.After all, it knows C++ at least as well as you do, and, in any case, it’s incapable of understanding comments.As far as the compiler is concerned, Listing 2.1 looks as if it were written without comments, like this:
#include <iostream>
int main()
{
using namespace std;
cout << "Come up and C++ me some time.";
cout << endl;
cout << "You won’t regret it!" << endl;
return 0;
}
C++ comments run from the // to the end of the line.A comment can be on its own line, or it can be on the same line as code. Incidentally, note the first line in Listing 2.1:
// myfirst.cpp -- displays a message
In this book all programs begin with a comment that gives the filename for the source code and a brief program summary.As mentioned in Chapter 1, the filename extension for source code depends on your C++ system. Other systems might use myfirst.C or
myfirst.cxx for names.


33
C++ Initiation
Tip
You should use comments to document your programs. The more complex the program, the more valuable comments are. Not only do they help others to understand what you have done, but also they help you understand what you’ve done, especially if you haven’t looked at the program for a while.
C-Style Comments
C++ also recognizes C comments, which are enclosed between /* and */ symbols:
#include <iostream> /* a C-style comment */
Because the C-style comment is terminated by */ rather than by the end of a line, you can spread it over more than one line. You can use either or both styles in your programs. However, try sticking to the C++ style. Because it doesn’t involve remembering to correctly pair an end symbol with a begin symbol, it’s less likely to cause problems. Indeed, C99 has added the // comment to the C language.
The C++ Preprocessor and the iostream File
Here’s the short version of what you need to know. If your program is to use the usual C++ input or output facilities, you provide these two lines:
#include <iostream>
using namespace std;
There are some alternatives to using the second line, but let’s keep things simple for now. (If your compiler doesn’t like these lines, it’s not C++98 compatible, and it will have many other problems with the examples in this book.) That’s all you really must know to make your programs work, but now let’s take a more in-depth look. C++, like C, uses a preprocessor.This is a program that processes a source file before the main compilation takes place. (Some C++ implementations, as you might recall from Chapter 1, use a translator program to convert a C++ program to C.Although the translator is also a form of preprocessor, we’re not discussing that preprocessor; instead, we’re discussing the one that handles directives whose names begin with #.) You don’t have to do anything special to invoke this preprocessor. It automatically operates when you compile the program. Listing 2.1 uses the #include directive:
#include <iostream> // a PREPROCESSOR directive
This directive causes the preprocessor to add the contents of the iostream file to your program.This is a typical preprocessor action: adding or replacing text in the source code before it’s compiled. This raises the question of why you should add the contents of the iostream file to the program.The answer concerns communication between the program and the outside world.The io in iostream refers to input, which is information brought into the program, and to output, which is information sent out from the program. C++’s input/output scheme involves several definitions found in the iostream file.Your first program needs


34 Chapter 2 Setting Out to C++
these definitions to use the cout facility to display a message.The #include directive causes the contents of the iostream file to be sent along with the contents of your file to the compiler. In essence, the contents of the iostream file replace the #include <iostream> line in the program.Your original file is not altered, but a composite file formed from your file and iostream goes on to the next stage of compilation.
Note
Programs that use cin and cout for input and output must include the iostream file.
Header Filenames
Files such as iostream are called include files (because they are included in other files) or header files (because they are included at the beginning of a file). C++ compilers come with many header files, each supporting a particular family of facilities.The C tradition has been to use the h extension with header files as a simple way to identify the type of file by its name. For example, the C math.h header file supports various C math functions. Initially, C++ did the same. For instance, the header file supporting input and output was named iostream.h. But C++ usage has changed. Now the h extension is reserved for the old C header files (which C++ programs can still use), whereas C++ header files have no extension.There are also C header files that have been converted to C++ header files. These files have been renamed by dropping the h extension (making it a C++-style name) and prefixing the filename with a c (indicating that it comes from C). For example, the C++ version of math.h is the cmath header file. Sometimes the C and C++ versions of C header files are identical, whereas in other cases the new version might have a few changes. For purely C++ header files such as iostream, dropping the h is more than a cosmetic change, for the h-free header files also incorporate namespaces, the next topic in this chapter.Table 2.1 summarizes the naming conventions for header files.
In view of the C tradition of using different filename extensions to indicate different file types, it appears reasonable to have some special extension, such as .hpp or .hxx, to indicate C++ header files.The ANSI/ISO committee felt so, too.The problem was agreeing on which extension to use, so eventually they agreed on nothing.
Table 2.1 Header File Naming Conventions
Kind of Header Convention Example Comments
C++ old style Ends in .h iostream.h Usable by C++ programs
C old style Ends in .h math.h Usable by C and C++ programs
C++ new style No extension iostream Usable by C++ programs, uses
namespace std
Converted C c prefix, no extension
cmath Usable by C++ programs, might use non-C features, such as namespace
std


35
C++ Initiation
Namespaces
If you use iostream instead of iostream.h, you should use the following namespace directive to make the definitions in iostream available to your program:
using namespace std;
This is called a using directive.The simplest thing to do is to accept this for now and worry about it later (for example, in Chapter 9,“Memory Models and Namespaces”). But so you won’t be left completely in the dark, here’s an overview of what’s happening. Namespace support is a C++ feature designed to simplify the writing of large programs and of programs that combine pre-existing code from several vendors and to help organize programs. One potential problem is that you might use two prepackaged products that both have, say, a function called wanda(). If you then use the wanda() function, the compiler won’t know which version you mean.The namespace facility lets a vendor package its wares in a unit called a namespace so that you can use the name of a namespace to indicate which vendor’s product you want. So Microflop Industries could place its definitions in a namespace called Microflop.Then Microflop::wanda() would become the full name for its wanda() function. Similarly, Piscine::wanda() could denote Piscine Corporation’s version of wanda().Thus, your program could now use the namespaces to discriminate between various versions:
Microflop::wanda("go dancing?"); // use Microflop namespace version
Piscine::wanda("a fish named Desire"); // use Piscine namespace version
In this spirit, the classes, functions, and variables that are a standard component of C++ compilers are now placed in a namespace called std.This takes place in the h-free header files.This means, for example, that the cout variable used for output and defined in iostream is really called std::cout and that endl is really std::endl.Thus, you can omit the using directive and, instead, code in the following style:
std::cout << "Come up and C++ me some time.";
std::cout << std::endl;
However, many users don’t feel like converting pre-namespace code, which uses iostream.h and cout, to namespace code, which uses iostream and std::cout, unless they can do so without a lot of hassle.This is where the using directive comes in.The following line means you can use names defined in the std namespace without using the std:: prefix:
using namespace std;
This using directive makes all the names in the std namespace available. Modern practice regards this as a bit lazy and potentially a problem in large projects.The preferred approaches are to use the std:: qualifier or to use something called a using declaration to make just particular names available:
using std::cout; // make cout available
using std::endl; // make endl available
using std::cin; // make cin available


36 Chapter 2 Setting Out to C++
If you use these directives instead of the following, you can use cin and cout without attaching std:: to them:
using namespace std; // lazy approach, all names available
But if you need to use other names from iostream, you have to add them to the using list individually.This book initially uses the lazy approach for a couple reasons. First, for simple programs, it’s not really a big issue which namespace management technique you use. Second, I’d rather emphasize the more basic aspects about learning C++. Later, the book uses the other namespace techniques.
C++ Output with cout
Now let’s look at how to display a message.The myfirst.cpp program uses the following C++ statement:
cout << "Come up and C++ me some time.";
The part enclosed within the double quotation marks is the message to print. In C++, any series of characters enclosed in double quotation marks is called a character string, presumably because it consists of several characters strung together into a larger unit.The << notation indicates that the statement is sending the string to cout; the symbols point the way the information flows.And what is cout? It’s a predefined object that knows how to display a variety of things, including strings, numbers, and individual characters. (An object, as you might remember from Chapter 1, is a particular instance of a class, and a class defines how data is stored and used.) Well, using objects so soon is a bit awkward because you won’t learn about objects for several more chapters.Actually, this reveals one of the strengths of objects.You don’t have to know the innards of an object in order to use it.All you must know is its interfacethat is, how to use it.The cout object has a simple interface. If string represents a string, you can do the following to display it:
cout << string;
This is all you must know to display a string, but now take a look at how the C++ conceptual view represents the process. In this view, the output is a stream—that is, a series of characters flowing from the program.The cout object, whose properties are defined in the iostream file, represents that stream.The object properties for cout include an insertion operator (<<) that inserts the information on its right into the stream. Consider the following statement (note the terminating semicolon):
cout << "Come up and C++ me some time.";
It inserts the string “Come up and C++ me some time.” into the output stream.Thus, rather than say that your program displays a message, you can say that it inserts a string into the output stream. Somehow, that sounds more impressive (see Figure 2.2).


37
C++ Initiation
...and then she said\nC++ RULES
cout << "C++ RULES"
s
tream
the insertion operator a string
string inserted into output stream
the cout object
and then
she said
C++ RULES
Figure 2.2 Using cout to display a string.
A First Look at Operator Overloading
If you’re coming to C++ from C, you probably noticed that the insertion operator (<<) looks just like the bitwise left-shift operator (<<). This is an example of operator overloading, by which the same operator symbol can have different meanings. The compiler uses the context to figure out which meaning is intended. C itself has some operator overloading. For example, the & symbol represents both the address operator and the bitwise AND operator. The * symbol represents both multiplication and dereferencing a pointer. The important point here is not the exact function of these operators but that the same symbol can have more than one meaning, with the compiler determining the proper meaning from the context. (You do much the same when you determine the meaning of “sound” in “sound card” versus “sound financial basis.”) C++ extends the operator overloading concept by letting you redefine operator meanings for the user-defined types called classes.
The Manipulator endl
Now let’s examine an odd-looking notation that appears in the second output statement in Listing 2.1:
cout << endl;
endl is a special C++ notation that represents the important concept of beginning a new line. Inserting endl into the output stream causes the screen cursor to move to the beginning of the next line. Special notations like endl that have particular meanings to


38 Chapter 2 Setting Out to C++
cout are dubbed manipulators. Like cout, endl is defined in the iostream header file and is part of the std namespace. Note that the cout facility does not move automatically to the next line when it prints a string, so the first cout statement in Listing 2.1 leaves the cursor positioned just after the period at the end of the output string.The output for each cout statement begins where the last output ended, so omitting endl would result in this output for Listing 2.1:
Come up and C++ me some time.You won’t regret it!
Note that the Y immediately follows the period. Let’s look at another example. Suppose you try this code:
cout << "The Good, the";
cout << "Bad, ";
cout << "and the Ukulele";
cout << endl;
It produces the following output:
The Good, theBad, and the Ukulele
Again, note that the beginning of one string comes immediately after the end of the preceding string. If you want a space where two strings join, you must include it in one of the strings. (Remember that to try out these output examples, you have to place them in a complete program, with a main() function header and opening and closing braces.)
The Newline Character
C++ has another, more ancient, way to indicate a new line in output—the C notation \n:
cout << "What’s next?\n"; // \n means start a new line
The \n combination is considered to be a single character called the newline character. If you are displaying a string, you need less typing to include the newline as part of the string than to tag an endl onto the end:
cout << "Pluto is a dwarf planet.\n"; // show text, go to next line
cout << "Pluto is a dwarf planet." << endl; // show text, go to next line
On the other hand, if you want to generate a newline by itself, both approaches take the same amount of typing, but most people find the keystrokes for endl to be more comfortable:
cout << "\n"; // start a new line
cout << endl; // start a new line
Typically, this book uses an embedded newline character (\n) when displaying quoted strings and the endl manipulator otherwise. One difference is that endl guarantees the output will be flushed (in, this case, immediately displayed onscreen) before the program moves on.You don’t get that guarantee with "\n", which means that it is possible on some


39
C++ Initiation
systems in some circumstances a prompt might not be displayed until after you enter the information being prompted for. The newline character is one example of special keystroke combinations termed “escape sequences”; they are further discussed in Chapter 3,“Dealing with Data.”
C++ Source Code Formatting
Some languages, such as FORTRAN, are line-oriented, with one statement to a line. For these languages, the carriage return (generated by pressing the Enter key or the Return key) serves to separate statements. In C++, however, the semicolon marks the end of each statement.This leaves C++ free to treat the carriage return in the same way as a space or a tab.That is, in C++ you normally can use a space where you would use a carriage return and vice versa.This means you can spread a single statement over several lines or place several statements on one line. For example, you could reformat myfirst.cpp as follows:
#include <iostream>
int
main
() { using
namespace
std; cout
<<
"Come up and C++ me some time."
; cout <<
endl; cout <<
"You won’t regret it!" <<
endl;return 0; }
This is visually ugly but valid code.You do have to observe some rules. In particular, in C and C++ you can’t put a space, tab, or carriage return in the middle of an element such as a name, nor can you place a carriage return in the middle of a string. Here are examples of what you can’t do:
int ma in() // INVALID -- space in name
re
turn 0; // INVALID -- carriage return in word
cout << "Behold the Beans
of Beauty!"; // INVALID -- carriage return in string
(However, the raw string, added by C++11 and discussed briefly in Chapter 4, does allow including a carriage return in a string.)
Tokens and White Space in Source Code
The indivisible elements in a line of code are called tokens (see Figure 2.3). Generally, you must separate one token from the next with a space, tab, or carriage return, which collectively are termed white space. Some single characters, such as parentheses and commas, are


40 Chapter 2 Setting Out to C++
int main() {
tokens
token
Spaces and carriage returns can be used interchangeably.
white space (newline) white space (space)
int
main () {
token
tokens
white space (newline) white space (space)
Figure 2.3 Tokens and white space.
tokens that need not be set off by white space. Here are some examples that illustrate when white space can be used and when it can be omitted:
return0; // INVALID, must be return 0;
return(0); // VALID, white space omitted
return (0); // VALID, white space used
intmain(); // INVALID, white space omitted
int main() // VALID, white space omitted in ()
int main ( ) // ALSO VALID, white space used in ( )
C++ Source Code Style
Although C++ gives you much formatting freedom, your programs will be easier to read if you follow a sensible style. Having valid but ugly code should leave you unsatisfied. Most programmers use styles similar to that of Listing 2.1, which observes these rules:
n One statement per line
n An opening brace and a closing brace for a function, each of which is on its own line
n Statements in a function indented from the braces
n No whitespace around the parentheses associated with a function name
The first three rules have the simple intent of keeping the code clean and readable.The fourth helps to differentiate functions from some built-in C++ structures, such as loops, that also use parentheses.This book alerts you to other guidelines as they come up.


41
C++ Statements
C++ Statements
A C++ program is a collection of functions, and each function is a collection of statements. C++ has several kinds of statements, so let’s look at some of the possibilities. Listing 2.2 provides two new kinds of statements. First, a declaration statement creates a variable. Second, an assignment statement provides a value for that variable.Also the program shows a new capability for cout.
Listing 2.2 carrots.cpp
// carrots.cpp -- food processing program
// uses and displays a variable
#include <iostream>
int main()
{
using namespace std;
int carrots; // declare an integer variable
carrots = 25; // assign a value to the variable
cout << "I have ";
cout << carrots; // display the value of the variable
cout << " carrots.";
cout << endl;
carrots = carrots - 1; // modify the variable
cout << "Crunch, crunch. Now I have " << carrots << " carrots." << endl;
return 0;
}
A blank line separates the declaration from the rest of the program.This practice is the usual C convention, but it’s somewhat less common in C++. Here is the program output for Listing 2.2:
I have 25 carrots.
Crunch, crunch. Now I have 24 carrots.
The next few pages examine this program.
Declaration Statements and Variables
Computers are precise, orderly machines.To store an item of information in a computer, you must identify both the storage location and how much memory storage space the information requires. One relatively painless way to do this in C++ is to use a declaration statement to indicate the type of storage and to provide a label for the location. For example, the program in Listing 2.2 has this declaration statement (note the semicolon):
int carrots;


42 Chapter 2 Setting Out to C++
This statement provides two kinds of information: the type of memory storage needed and a label to attach to that storage. In particular, the statement declares that the program requires enough storage to hold an integer, for which C++ uses the label int.The compiler takes care of the details of allocating and labeling memory for that task. C++ can handle several kinds, or types, of data, and the int is the most basic data type. It corresponds to an integer, a number with no fractional part.The C++ int type can be positive or negative, but the size range depends on the implementation. Chapter 3 provides the details on int and the other basic types. Naming the storage is the second task achieved. In this case, the declaration statement declares that henceforth the program will use the name carrots to identify the value stored at that location. carrots is called a variable because you can change its value. In C++ you must declare all variables. If you were to omit the declaration in carrots.cpp, the compiler would report an error when the program attempts to use carrots further on. (In fact, you might want to try omitting the declaration just to see how your compiler responds.Then if you see that response in the future, you’ll know to check for omitted declarations.)
Why Must Variables Be Declared?
Some languages, notably BASIC, create a new variable whenever you use a new name, without the aid of explicit declarations. That might seem friendlier to the user, and it is—in the short term. The problem is that if you misspell the name of a variable, you inadvertently can create a new variable without realizing it. That is, in BASIC, you can do something like the following:
CastleDark = 34 ... CastleDank = CastleDark + MoreGhosts ...
PRINT CastleDark
Because CastleDank is misspelled (the r was typed as an n), the changes you make to it leave CastleDark unchanged. This kind of error can be hard to trace because it breaks no rules in BASIC. However, in C++, CastleDark would be declared while the misspelled CastleDank would not be declared. Therefore, the equivalent C++ code breaks the rule about the need to declare a variable for you to use it, so the compiler catches the error and stomps the potential bug.
In general, then, a declaration indicates the type of data to be stored and the name the program will use for the data that’s stored there. In this particular case, the program creates a variable called carrots in which it can store an integer (see Figure 2.4). The declaration statement in the program is called a defining declaration statement, or definition, for short.This means that its presence causes the compiler to allocate memory space for the variable. In more complex situations, you can also have reference declarations. These tell the computer to use a variable that has already been defined elsewhere. In general, a declaration need not be a definition, but in this example it is.


43
C++ Statements
semicolon marks end of statement
type of data to be stored
name of variable
int carrots;
Figure 2.4 A variable declaration.
If you’re familiar with C or Pascal, you’re already familiar with variable declarations. You also might have a modest surprise in store for you. In C and Pascal, all variable declarations normally come at the very beginning of a function or procedure. But C++ has no such restriction. Indeed, the usual C++ style is to declare a variable just before it is first used.That way, you don’t have to rummage back through a program to see what the type is.You’ll see an example of this later in this chapter.This style does have the disadvantage of not gathering all your variable names in one place; thus, you can’t tell at a glance what variables a function uses. (Incidentally, C99 now makes the rules for C declarations much the same as for C++.)
Tip
The C++ style for declaring variables is to declare a variable as close to its first use as possible.
Assignment Statements
An assignment statement assigns a value to a storage location. For example, the following statement assigns the integer 25 to the location represented by the variable carrots:
carrots = 25;
The = symbol is called the assignment operator. One unusual feature of C++ (and C) is that you can use the assignment operator serially. For example, the following is valid code:
int steinway;
int baldwin;
int yamaha;
yamaha = baldwin = steinway = 88;
The assignment works from right to left. First, 88 is assigned to steinway; then the value of steinway, which is now 88, is assigned to baldwin; then baldwin’s value of 88 is assigned to yamaha. (C++ follows C’s penchant for allowing weird-appearing code.) The second assignment statement in Listing 2.2 demonstrates that you can change the value of a variable:
carrots = carrots - 1; // modify the variable


44 Chapter 2 Setting Out to C++
The expression to the right of the assignment operator (carrots – 1) is an example of an arithmetic expression.The computer will subtract 1 from 25, the value of carrots, obtaining 24.The assignment operator then stores this new value in the carrots location.
A New Trick for cout
Up until now, the examples in this chapter have given cout strings to print. Listing 2.2 also gives cout a variable whose value is an integer:
cout << carrots;
The program doesn’t print the word carrots; instead, it prints the integer value stored in carrots, which is 25. Actually, this is two tricks in one. First, cout replaces carrots with its current numeric value of 25. Second, it translates the value to the proper output characters. As you can see, cout works with both strings and integers.This might not seem particularly remarkable to you, but keep in mind that the integer 25 is something quite different from the string "25".The string holds the characters with which you write the number (that is, a 2 character and a 5 character).The program internally stores the numeric codes for the 2 character and the 5 character.To print the string, cout simply prints each character in the string. But the integer 25 is stored as a numeric value. Rather than store each digit separately, the computer stores 25 as a binary number. (Appendix A,“Number Bases,” discusses this representation.) The main point here is that cout must translate a number in integer form into character form before it can print it. Furthermore, cout is smart enough to recognize that carrots is an integer that requires conversion. Perhaps the contrast with old C will indicate how clever cout is.To print the string "25" and the integer 25 in C, you could use C’s multipurpose output function printf():
printf("Printing a string: %s\n", "25");
printf("Printing an integer: %d\n", 25);
Without going into the intricacies of printf(), note that you must use special codes (%s and %d) to indicate whether you are going to print a string or an integer.And if you tell printf() to print a string but give it an integer by mistake, printf() is too unsophisticated to notice your mistake. It just goes ahead and displays garbage. The intelligent way in which cout behaves stems from C++’s object-oriented features. In essence, the C++ insertion operator (<<) adjusts its behavior to fit the type of data that follows it.This is an example of operator overloading. In later chapters, when you take up function overloading and operator overloading, you’ll learn how to implement such smart designs yourself.
cout and printf()
If you are used to C and printf(), you might think cout looks odd. You might even prefer to cling to your hard-won mastery of printf(). But cout actually is no stranger in appearance than printf(), with all its conversion specifications. More importantly, cout has significant advantages. Its capability to recognize types reflects a more intelligent and foolproof


45
More C++ Statements
design. Also, it is extensible. That is, you can redefine the << operator so that cout can recognize and display new data types you develop. And if you relish the fine control printf() provides, you can accomplish the same effects with more advanced uses of cout (see Chapter 17, “Input, Output, and Files”).
More C++ Statements
Let’s look at a couple more examples of statements.The program in Listing 2.3 expands on the preceding example by allowing you to enter a value while the program is running. To do so, it uses cin (pronounced “see-in”), the input counterpart to cout.Also the program shows yet another way to use that master of versatility, the cout object.
Listing 2.3 getinfo.cpp
// getinfo.cpp -- input and output
#include <iostream>
int main()
{
using namespace std;
int carrots;
cout << "How many carrots do you have?" << endl;
cin >> carrots; // C++ input
cout << "Here are two more. ";
carrots = carrots + 2;
// the next line concatenates output
cout << "Now you have " << carrots << " carrots." << endl;
return 0;
}
Program Adjustments
If you found that you had to add a cin.get() statement in the earlier listings, you will need to add two cin.get() statements to this listing to keep the program output visible onscreen. The first one will read the newline generated when you press the Enter or Return key after typing a number, and the second will cause the program to pause until you hit Return or Enter again.
Here is an example of output from the program in Listing 2.3:
How many carrots do you have?
12
Here are two more. Now you have 14 carrots.
The program has two new features: using cin to read keyboard input and combining four output statements into one. Let’s take a look.


46 Chapter 2 Setting Out to C++
Using cin
As the output from Listing 2.3 demonstrates, the value typed from the keyboard (12) is eventually assigned to the variable carrots.The following statement performs that wonder:
cin >> carrots;
Looking at this statement, you can practically see information flowing from cin into carrots. Naturally, there is a slightly more formal description of this process. Just as C++ considers output to be a stream of characters flowing out of the program, it considers input to be a stream of characters flowing into the program.The iostream file defines cin as an object that represents this stream. For output, the << operator inserts characters into the output stream. For input, cin uses the >> operator to extract characters from the input stream.Typically, you provide a variable to the right of the operator to receive the extracted information. (The symbols << and >> were chosen to visually suggest the direction in which information flows.) Like cout, cin is a smart object. It converts input, which is just a series of characters typed from the keyboard, into a form acceptable to the variable receiving the information. In this case, the program declares carrots to be an integer variable, so the input is converted to the numeric form the computer uses to store integers.
Concatenating with cout
The second new feature of getinfo.cpp is combining four output statements into one. The iostream file defines the << operator so that you can combine (that is, concatenate) output as follows:
cout << "Now you have " << carrots << " carrots." << endl;
This allows you to combine string output and integer output in a single statement.The resulting output is the same as what the following code produces:
cout << "Now you have ";
cout << carrots;
cout << " carrots";
cout << endl;
While you’re still in the mood for cout advice, you can also rewrite the concatenated version this way, spreading the single statement over four lines:
cout << "Now you have "
<< carrots
<< " carrots."
<< endl;
That’s because C++’s free format rules treat newlines and spaces between tokens interchangeably.This last technique is convenient when the line width cramps your style. Another point to note is that
Now you have 14 carrots.


47
More C++ Statements
appears on the same line as
Here are two more.
That’s because, as noted before, the output of one cout statement immediately follows the output of the preceding cout statement.This is true even if there are other statements in between.
cin and cout: A Touch of Class
You’ve seen enough of cin and cout to justify your exposure to a little object lore. In particular, in this section you’ll learn more about the notion of classes. As Chapter 1 outlined briefly, classes are one of the core concepts for object-oriented programming (OOP) in C++. A class is a data type the user defines.To define a class, you describe what sort of information it can represent and what sort of actions you can perform with that data.A class bears the same relationship to an object that a type does to a variable.That is, a class definition describes a data form and how it can be used, whereas an object is an entity created according to the data form specification. Or, in noncomputer terms, if a class is analogous to a category such as famous actors, then an object is analogous to a particular example of that category, such as Kermit the Frog.To extend the analogy, a class representation of actors would include definitions of possible actions relating to the class, such as Reading for a Part, Expressing Sorrow, Projecting Menace,Accepting an Award, and the like. If you’ve been exposed to different OOP terminology, it might help to know that the C++ class corresponds to what some languages term an object type, and the C++ object corresponds to an object instance or instance variable. Now let’s get a little more specific. Recall the following declaration of a variable:
int carrots;
This creates a particular variable (carrots) that has the properties of the int type.That is, carrots can store an integer and can be used in particular ways—for addition and subtraction, for example. Now consider cout. It is an object created to have the properties of the ostream class.The ostream class definition (another inhabitant of the iostream file) describes the sort of data an ostream object represents and the operations you can perform with and to it, such as inserting a number or string into an output stream. Similarly, cin is an object created with the properties of the istream class, also defined in
iostream.
Note
The class describes all the properties of a data type, including actions that can be performed with it, and an object is an entity created according to that description.
You have learned that classes are user-defined types, but as a user, you certainly didn’t design the ostream and istream classes. Just as functions can come in function libraries, classes can come in class libraries.That’s the case for the ostream and istream classes. Technically, they are not built in to the C++ language; instead, they are examples of classes


48 Chapter 2 Setting Out to C++
Trust me
#include <iostream> using namespace std; int main() {
... ... cout << "Trust me"; ... ... }
print message
object displays argument
message argument
cout object
Figure 2.5 Sending a message to an object.
that the language standard specifies.The class definitions are laid out in the iostream file and are not built into the compiler.You can even modify these class definitions if you like, although that’s not a good idea. (More precisely, it is a truly dreadful idea.) The iostream family of classes and the related fstream (or file I/O) family are the only sets of class definitions that came with all early implementations of C++. However, the ANSI/ISO C++ committee added a few more class libraries to the Standard.Also most implementations provide additional class definitions as part of the package. Indeed, much of the current appeal of C++ is the existence of extensive and useful class libraries that support Unix, Macintosh, and Windows programming. The class description specifies all the operations that can be performed on objects of that class.To perform such an allowed action on a particular object, you send a message to the object. For example, if you want the cout object to display a string, you send it a message that says, in effect,“Object! Display this!” C++ provides a couple ways to send messages. One way, using a class method, is essentially a function call like the ones you’ll see soon.The other way, which is the one used with cin and cout, is to redefine an operator. Thus, the following statement uses the redefined << operator to send the “display message” to cout:
cout << "I am not a crook."
In this case, the message comes with an argument, which is the string to be displayed. (See Figure 2.5 for a similar example.)
Functions
Because functions are the modules from which C++ programs are built and because they are essential to C++ OOP definitions, you should become thoroughly familiar with them. Some aspects of functions are advanced topics, so the main discussion of functions comes later, in Chapter 7,“Functions: C++’s Programming Modules,” and Chapter 8,


49
Functions
int main() {
... ... x = sqrt(6.25); ... ...
code for sqrt() ... ... ... ... ... ...
❶ ❷❸
❺
Calling Function Called Function
❹
return
to
a
calling
function
function call
Figure 2.6 Calling a function.
“Adventures in Functions.” However, if we deal now with some basic characteristics of functions, you’ll be more at ease and more practiced with functions later.The rest of this chapter introduces you to these function basics. C++ functions come in two varieties: those with return values and those without them.You can find examples of each kind in the standard C++ library of functions, and you can create your own functions of each type. Let’s look at a library function that has a return value and then examine how you can write your own simple functions.
Using a Function That Has a Return Value
A function that has a return value produces a value that you can assign to a variable or use in some other expression. For example, the standard C/C++ library includes a function called sqrt() that returns the square root of a number. Suppose you want to calculate the square root of 6.25 and assign it to the variable x.You can use the following statement in your program:
x = sqrt(6.25); // returns the value 2.5 and assigns it to x
The expression sqrt(6.25) invokes, or calls, the sqrt() function.The expression sqrt(6.25) is termed a function call, the invoked function is termed the called function, and the function containing the function call is termed the calling function (see Figure 2.6).
The value in the parentheses (6.25, in this example) is information that is sent to the function; it is said to be passed to the function.A value that is sent to a function this way is called an argument or parameter (see Figure 2.7).The sqrt() function calculates the answer to be 2.5 and sends that value back to the calling function; the value sent back is termed the return value of the function.Think of the return value as what is substituted for the function call in the statement after the function finishes its job.Thus, this example assigns the return value to the variable x. In short, an argument is information sent to the function, and the return value is a value sent back from the function.


50 Chapter 2 Setting Out to C++
x = sqrt(6.25);
function name
function return value assigned to x
closing parenthesis
semicolon marks end of statement
opening parenthesis
argumentinformation passed to function
Figure 2.7 Function call syntax.
That’s practically all there is to it, except that before the C++ compiler uses a function, it must know what kind of arguments the function uses and what kind of return value it has.That is, does the function return an integer? a character? a number with a decimal fraction? a guilty verdict? or something else? If it lacks this information, the compiler won’t know how to interpret the return value.The C++ way to convey this information is to use a function prototype statement.
Note
A C++ program should provide a prototype for each function used in the program.
A function prototype does for functions what a variable declaration does for variables: It tells what types are involved. For example, the C++ library defines the sqrt() function to take a number with (potentially) a fractional part (like 6.25) as an argument and to return a number of the same type. Some languages refer to such numbers as real numbers, but the name C++ uses for this type is double. (You’ll see more of double in Chapter 3.) The function prototype for sqrt() looks like this:
double sqrt(double); // function prototype
The initial double means sqrt() returns a type double value.The double in the parentheses means sqrt() requires a double argument. So this prototype describes sqrt() exactly as used in the following code:
double x; // declare x as a type double variable
x = sqrt(6.25);
The terminating semicolon in the prototype identifies it as a statement and thus makes it a prototype instead of a function header. If you omit the semicolon, the compiler interprets the line as a function header and expects you to follow it with a function body that defines the function.


51
Functions
When you use sqrt() in a program, you must also provide the prototype.You can do this in either of two ways:
n You can type the function prototype into your source code file yourself.
n You can include the cmath (math.h on older systems) header file, which has the prototype in it.
The second way is better because the header file is even more likely than you to get the prototype right. Every function in the C++ library has a prototype in one or more header files. Just check the function description in your manual or with online help, if you have it, and the description tells you which header file to use. For example, the description of the sqrt() function should tell you to use the cmath header file. (Again, you might have to use the older math.h header file, which works for both C and C++ programs.) Don’t confuse the function prototype with the function definition.The prototype, as you’ve seen, only describes the function interface.That is, it describes the information sent to the function and the information sent back.The definition, however, includes the code for the function’s workings—for example, the code for calculating the square root of a number. C and C++ divide these two features—prototype and definition—for library functions.The library files contain the compiled code for the functions, whereas the header files contain the prototypes. You should place a function prototype ahead of where you first use the function.The usual practice is to place prototypes just before the definition of the main() function. Listing 2.4 demonstrates the use of the library function sqrt(); it provides a prototype by including the cmath file.
Listing 2.4 sqrt.cpp
// sqrt.cpp -- using the sqrt() function
#include <iostream>
#include <cmath> // or math.h
int main()
{
using namespace std;
double area;
cout << "Enter the floor area, in square feet, of your home: ";
cin >> area;
double side;
side = sqrt(area);
cout << "That’s the equivalent of a square " << side
<< " feet to the side." << endl;
cout << "How fascinating!" << endl;
return 0;
}


52 Chapter 2 Setting Out to C++
Using Library Functions
C++ library functions are stored in library files. When the compiler compiles a program, it must search the library files for the functions you’ve used. Compilers differ on which library files they search automatically. If you try to run Listing 2.4 and get a message that _sqrt is an undefined external (sounds like a condition to avoid!), chances are that your compiler doesn’t automatically search the math library. (Compilers like to add an underscore prefix to function names—another subtle reminder that they have the last say about your program.) If you get such a message, check your compiler documentation to see how to have the compiler search the correct library. If you get such a complaint on a Unix implementation, for example, it may require that you use the -lm option (for library math) at the end of the command line:
CC sqrt.C -lm
Some versions of the Gnu compiler under Linux behave similarly:
g++ sqrt.C –lm
Merely including the cmath header file provides the prototype but does not necessarily cause the compiler to search the correct library file.
Here’s a sample run of the program in Listing 2.4:
Enter the floor area, in square feet, of your home: 1536
That’s the equivalent of a square 39.1918 feet to the side.
How fascinating!
Because sqrt() works with type double values, the example makes the variables that type. Note that you declare a type double variable by using the same form, or syntax, as when you declare a type int variable:
type-name variable-name;
Type double allows the variables area and side to hold values with decimal fractions, such as 1536.0 and 39.1918. An apparent integer, such as 1536, is stored as a real value with a decimal fraction part of .0 when stored in a type double variable. As you’ll see in Chapter 3, type double encompasses a much greater range of values than type int. C++ allows you to declare new variables anywhere in a program, so sqrt.cpp didn’t declare side until just before using it. C++ also allows you to assign a value to a variable when you create it, so you could also have done this:
double side = sqrt(area);
You’ll learn more about this process, called initialization, in Chapter 3. Note that cin knows how to convert information from the input stream to type double, and cout knows how to insert type double into the output stream. As noted earlier, these objects are smart.


53
Functions
Function Variations
Some functions require more than one item of information.These functions use multiple arguments separated by commas. For example, the math function pow() takes two arguments and returns a value equal to the first argument raised to the power given by the second argument. It has this prototype:
double pow(double, double); // prototype of a function with two arguments
If, say, you wanted to find 58 (5 to the eighth power), you would use the function like this:
answer = pow(5.0, 8.0); // function call with a list of arguments
Other functions take no arguments. For example, one of the C libraries (the one associated with the cstdlib or the stdlib.h header file) has a rand() function that has no arguments and that returns a random integer. Its prototype looks like this:
int rand(void); // prototype of a function that takes no arguments
The keyword void explicitly indicates that the function takes no arguments. If you omit void and leave the parentheses empty, C++ interprets this as an implicit declaration that there are no arguments.You could use the function this way:
myGuess = rand(); // function call with no arguments
Note that unlike some computer languages, in C++ you must use the parentheses in the function call even if there are no arguments. There also are functions that have no return value. For example, suppose you wrote a function that displayed a number in dollars-and-cents format.You could send to it an argument of, say, 23.5, and it would display $23.50 onscreen. Because this function sends a value to the screen instead of to the calling program, it doesn’t require a return value.You indicate this in the prototype by using the keyword void for the return type:
void bucks(double); // prototype for function with no return value
Because bucks() doesn’t return a value, you can’t use this function as part of an assignment statement or of some other expression. Instead, you have a pure function call statement:
bucks(1234.56); // function call, no return value
Some languages reserve the term function for functions with return values and use the terms procedure or subroutine for those without return values, but C++, like C, uses the term function for both variations.
User-Defined Functions
The standard C library provides more than 140 predefined functions. If one fits your needs, by all means use it. But often you have to write your own, particularly when you design classes.Anyway, it’s fun to design your own functions, so now let’s examine that process.You’ve already used several user-defined functions, and they have all been named main(). Every C++ program must have a main() function, which the user must define.


54 Chapter 2 Setting Out to C++
Suppose you want to add a second user-defined function. Just as with a library function, you can call a user-defined function by using its name.And, as with a library function, you must provide a function prototype before using the function, which you typically do by placing the prototype above the main() definition. But now you, not the library vendor, must provide source code for the new function.The simplest way is to place the code in the same file after the code for main(). Listing 2.5 illustrates these elements.
Listing 2.5 ourfunc.cpp
// ourfunc.cpp -- defining your own function
#include <iostream>
void simon(int); // function prototype for simon()
int main()
{
using namespace std;
simon(3); // call the simon() function
cout << "Pick an integer: ";
int count;
cin >> count;
simon(count); // call it again
cout << "Done!" << endl;
return 0;
}
void simon(int n) // define the simon() function
{
using namespace std;
cout << "Simon says touch your toes " << n << " times." << endl;
} // void functions don’t need return statements
The main() function calls the simon() function twice, once with an argument of 3 and once with a variable argument count. In between, the user enters an integer that’s used to set the value of count.The example doesn’t use a newline character in the cout prompting message.This results in the user input appearing on the same line as the prompt. Here is a sample run of the program in Listing 2.5:
Simon says touch your toes 3 times.
Pick an integer: 512
Simon says touch your toes 512 times.
Done!
Function Form
The definition for the simon() function in Listing 2.5 follows the same general form as the definition for main(). First, there is a function header.Then, enclosed in braces, comes the function body. You can generalize the form for a function definition as follows:


55
Functions
function prototypes
function #1
function #2
function #3
#include <iostream> using namespace std;
void simon(int); double taxes(double);
int main() {
... return 0; }
void simon(int n) {
... }
double taxes(double t) {
... return 2 * t; }
Figure 2.8 Function definitions occur sequentially in a file.
type functionname(argumentlist)
{
statements
}
Note that the source code that defines simon() follows the closing brace of main(). Like C, and unlike Pascal, C++ does not allow you to embed one function definition inside another. Each function definition stands separately from all others; all functions are created equal (see Figure 2.8).
Function Headers
The simon() function in Listing 2.5 has this header:
void simon(int n)
The initial void means that simon() has no return value. So calling simon() doesn’t produce a number that you can assign to a variable in main().Thus, the first function call looks like this:
simon(3); // ok for void functions
Because poor simon() lacks a return value, you can’t use it this way:
simple = simon(3); // not allowed for void functions
The int n within the parentheses means that you are expected to use simon() with a single argument of type int.The n is a new variable assigned the value passed during a


56 Chapter 2 Setting Out to C++
function call.Thus, the following function call assigns the value 3 to the n variable defined in the simon() header:
simon(3);
When the cout statement in the function body uses n, it uses the value passed in the function call.That’s why simon(3) displays a 3 in its output.The call to simon(count) in the sample run causes the function to display 512 because that was the value entered for count. In short, the header for simon() tells you that this function takes a single type int argument and that it doesn’t have a return value. Let’s review main()’s function header:
int main()
The initial int means that main() returns an integer value.The empty parentheses (which optionally could contain void) means that main() has no arguments. Functions that have return values should use the keyword return to provide the return value and to terminate the function.That’s why you’ve been using the following statement at the end
of main():
return 0;
This is logically consistent: main() is supposed to return a type int value, and you have it return the integer 0. But, you might wonder, to what are you returning a value? After all, nowhere in any of your programs have you seen anything calling main():
squeeze = main(); // absent from our programs
The answer is that you can think of your computer’s operating system (Unix, say, or Windows) as calling your program. So main()’s return value is returned not to another part of the program but to the operating system. Many operating systems can use the program’s return value. For example, Unix shell scripts and Window’s command-line interface batch files can be designed to run programs and test their return values, usually called exit values.The normal convention is that an exit value of zero means the program ran successfully, whereas a nonzero value means there was a problem.Thus, you can design a C++ program to return a nonzero value if, say, it fails to open a file.You can then design a shell script or batch file to run that program and to take some alternative action if the program signals failure.
Keywords
Keywords are the vocabulary of a computer language. This chapter has used four C++ keywords: int, void, return, and double. Because these keywords are special to C++, you can’t use them for other purposes. That is, you can’t use return as the name for a variable or double as the name of a function. But you can use them as part of a name, as in painter (with its hidden int) or return_aces. Appendix B, “C++ Reserved Words,” provides a complete list of C++ keywords. Incidentally, main is not a keyword because it’s not part of the language. Instead, it is the name of a required function. You can use main as a variable name. (That can cause a problem in circumstances too esoteric to describe here, and because it is confusing in any case, you’d best not.) Similarly, other function names and


57
Functions
object names are not keywords. However, using the same name, say cout, for both an object and a variable in a program confuses the compiler. That is, you can use cout as a variable name in a function that doesn’t use the cout object for output, but you can’t use cout both ways in the same function.
Using a User-Defined Function That Has a Return Value
Let’s go one step further and write a function that uses the return statement.The main() function already illustrates the plan for a function with a return value: Give the return type in the function header and use return at the end of the function body.You can use this form to solve a weighty problem for those visiting the United Kingdom. In the United Kingdom, many bathroom scales are calibrated in stone instead of in U.S. pounds or international kilograms.The word stone is both singular and plural in this context. (The English language does lack the internal consistency of, say, C++.) One stone is 14 pounds, and the program in Listing 2.6 uses a function to make this conversion.
Listing 2.6 convert.cpp
// convert.cpp -- converts stone to pounds
#include <iostream>
int stonetolb(int); // function prototype
int main()
{
using namespace std;
int stone;
cout << "Enter the weight in stone: ";
cin >> stone;
int pounds = stonetolb(stone);
cout << stone << " stone = ";
cout << pounds << " pounds." << endl;
return 0;
}
int stonetolb(int sts)
{
return 14 * sts;
}
Here’s a sample run of the program in Listing 2.6:
Enter the weight in stone: 15
15 stone = 210 pounds.
In main(), the program uses cin to provide a value for the integer variable stone.This value is passed to the stonetolb() function as an argument and is assigned to the variable sts in that function. stonetolb() then uses the return keyword to return the value of 14 * sts to main().This illustrates that you aren’t limited to following return with a simple number. Here, by using a more complex expression, you avoid the bother of having


58 Chapter 2 Setting Out to C++
int stonetolb(int);
typeintvalue
goesintofunction
functionreturn
typeint
stonetolb() 14
196
Figure 2.9 The function prototype and the function as a black box.
to create a new variable to which to assign the value before returning it.The program calculates the value of that expression (210 in this example) and returns the resulting value. If returning the value of an expression bothers you, you can take the longer route:
int stonetolb(int sts)
{
int pounds = 14 * sts;
return pounds;
}
Both versions produce the same result.The second version, because it separates the computation process from the return process, is easier to read and modify. In general, you can use a function with a return value wherever you would use a simple constant of the same type. For example, stonetolb() returns a type int value.This means you can use the function in the following ways:
int aunt = stonetolb(20);
int aunts = aunt + stonetolb(10);
cout << "Ferdie weighs " << stonetolb(16) << " pounds." << endl;
In each case, the program calculates the return value and then uses that number in these statements. As these examples show, the function prototype describes the function interface—that is, how the function interacts with the rest of the program.The argument list shows what sort of information goes into the function, and the function type shows the type of value returned. Programmers sometimes describe functions as black boxes (a term from electronics) specified by the flow of information into and out of them.The function prototype perfectly portrays that point of view (see Figure 2.9).
The stonetolb() function is short and simple, yet it embodies a full range of functional features:
n It has a header and a body.
n It accepts an argument.


59
Functions
n It returns a value.
n It requires a prototype.
Consider stonetolb() as a standard form for function design.You’ll further explore functions in Chapters 7 and 8. In the meantime, the material in this chapter should give you a good feel for how functions work and how they fit into C++.
Placing the using Directive in Multifunction Programs
Notice that Listing 2.5 places a using directive in each of the two functions:
using namespace std;
This is because each function uses cout and thus needs access to the cout definition from the std namespace. There’s another way to make the std namespace available to both functions in Listing 2.5, and that’s to place the directive outside and above both functions:
// ourfunc1.cpp -- repositioning the using directive
#include <iostream>
using namespace std; // affects all function definitions in this file
void simon(int);
int main()
{
simon(3);
cout << "Pick an integer: ";
int count;
cin >> count;
simon(count);
cout << "Done!" << endl;
return 0;
}
void simon(int n)
{
cout << "Simon says touch your toes " << n << " times." << endl;
}
The current prevalent philosophy is that it’s preferable to be more discriminating and limit access to the std namespace to only those functions that need access. For example, in Listing 2.6, only main() uses cout, so there is no need to make the std namespace available to the stonetolb() function.Thus, the using directive is placed inside the main() function only, limiting std namespace access to just that function.


60 Chapter 2 Setting Out to C++
In summary, you have several choices for making std namespace elements available to a program. Here are some:
n You can place the following above the function definitions in a file, making all the contents of the std namespace available to every function in the file:
using namespace std;
n You can place the following in a specific function definition, making all the contents of the std namespace available to that specific function:
using namespace std;
n Instead of using
using namespace std;
you can place using declarations like the following in a specific function definition and make a particular element, such as cout, available to that function:
using std::cout;
n You can omit the using directives and declarations entirely and use the std:: prefix whenever you use elements from the std namespace:
std::cout << "I’m using cout and endl from the std namespace" << std::endl;
Naming Conventions
C++ programmers are blessed (or cursed) with myriad options when naming functions, classes, and variables. Programmers have strong and varied opinions about style, and these often surface as holy wars in public forums. Starting with the same basic idea for a function name, a programmer might select any of the following:
MyFunction( ) myfunction( ) myFunction( ) my_function( )
my_funct( )
The choice will depend on the development team, the idiosyncrasies of the technologies or libraries used, and the tastes and preferences of the individual programmer. Rest assured that any style consistent with the C++ rules presented in Chapter 3 is correct as far as the C++ language is concerned, and it can be used based on your own judgment.
Language allowances aside, it is worth noting that a personal naming style—one that aids you through consistency and precision—is well worth pursuing. A precise, recognizable personal naming convention is a hallmark of good software engineering, and it will aid you throughout your programming career.


61
Summary
Summary
A C++ program consists of one or more modules called functions. Programs begin executing at the beginning of the function called main() (all lowercase), so you should always have a function by this name.A function, in turn, consists of a header and a body. The function header tells you what kind of return value, if any, the function produces and what sort of information it expects arguments to pass to it.The function body consists of a series of C++ statements enclosed in paired braces ({}). C++ statement types include the following:
n Declaration statement—A declaration statement announces the name and the type of a variable used in a function.
n Assignment statement—An assignment statement uses the assignment operator (=) to assign a value to a variable.
n Message statement—A message statement sends a message to an object, initiating some sort of action.
n Function call—A function call activates a function.When the called function terminates, the program returns to the statement in the calling function immediately following the function call.
n Function prototype—A function prototype declares the return type for a function, along with the number and type of arguments the function expects.
n Return statement—A return statement sends a value from a called function back to the calling function.
A class is a user-defined specification for a data type.This specification details how information is to be represented and also the operations that can be performed with the data.An object is an entity created according to a class prescription, just as a simple variable is an entity created according to a data type description. C++ provides two predefined objects (cin and cout) for handling input and output. They are examples of the istream and ostream classes, which are defined in the iostream file.These classes view input and output as streams of characters.The insertion operator (<<), which is defined for the ostream class, lets you insert data into the output stream, and the extraction operator (>>), which is defined for the istream class, lets you extract information from the input stream. Both cin and cout are smart objects, capable of automatically converting information from one form to another according to the program context. C++ can use the extensive set of C library functions.To use a library function, you should include the header file that provides the prototype for the function. Now that you have an overall view of simple C++ programs, you can go on in the next chapters to fill in details and expand horizons.


62 Chapter 2 Setting Out to C++
Chapter Review
You can find the answers to the chapter review at the end of each chapter in Appendix J, “Answers to Chapter Review.”
1. What are the modules of C++ programs called?
2. What does the following preprocessor directive do?
#include <iostream>
3. What does the following statement do?
using namespace std;
4. What statement would you use to print the phrase “Hello, world” and then start a new line?
5. What statement would you use to create an integer variable with the name
cheeses?
6. What statement would you use to assign the value 32 to the variable cheeses?
7. What statement would you use to read a value from keyboard input into the vari
able cheeses?
8. What statement would you use to print “We have X varieties of cheese,” where the current value of the cheeses variable replaces X?
9. What do the following function prototypes tell you about the functions?
int froop(double t);
void rattle(int n);
int prune(void);
10. When do you not have to use the keyword return when you define a function?
11. Suppose your main() function has the following line:
cout << “Please enter your PIN: “;
And suppose the compiler complains that cout is an unknown identifier.What is the likely cause of this complaint, and what are three ways to fix the problem?
Programming Exercises
1. Write a C++ program that displays your name and address (or if you value your privacy, a fictitious name and address).
2. Write a C++ program that asks for a distance in furlongs and converts it to yards. (One furlong is 220 yards.)


63
Programming Exercises
3. Write a C++ program that uses three user-defined functions (counting main() as one) and produces the following output:
Three blind mice
Three blind mice
See how they run
See how they run
One function, called two times, should produce the first two lines, and the remaining function, also called twice, should produce the remaining output.
4. Write a program that asks the user to enter his or her age.The program then should display the age in months:
Enter your age: 29
Your age in months is 384.
5. Write a program that has main() call a user-defined function that takes a Celsius temperature value as an argument and then returns the equivalent Fahrenheit value. The program should request the Celsius value as input from the user and display the result, as shown in the following code:
Please enter a Celsius value: 20
20 degrees Celsius is 68 degrees Fahrenheit.
For reference, here is the formula for making the conversion:
Fahrenheit = 1.8 × degrees Celsius + 32.0
6. Write a program that has main() call a user-defined function that takes a distance in light years as an argument and then returns the distance in astronomical units. The program should request the light year value as input from the user and display the result, as shown in the following code:
Enter the number of light years: 4.2
4.2 light years = 265608 astronomical units.
An astronomical unit is the average distance from the earth to the sun (about 150,000,000 km or 93,000,000 miles), and a light year is the distance light travels in a year (about 10 trillion kilometers or 6 trillion miles). (The nearest star after the sun is about 4.2 light years away.) Use type double (as in Listing 2.4) and this conversion factor:
1 light year = 63,240 astronomical units
7. Write a program that asks the user to enter an hour value and a minute value.The main() function should then pass these two values to a type void function that displays the two values in the format shown in the following sample run:
Enter the number of hours: 9
Enter the number of minutes: 28
Time: 9:28


This page intentionally left blank


3
Dealing with Data
I
n this chapter you’ll learn about the following:
n Rules for naming C++ variables
n C++’s built-in integer types: unsigned long, long, unsigned int, int, unsigned
short, short, char, unsigned char, signed char, bool
n C++11’s additions: unsigned long long and long long
n The climits file, which represents system limits for various integer types
n Numeric literals (constants) of various integer types
n Using the const qualifier to create symbolic constants
n C++’s built-in floating-point types: float, double, and long double
n The cfloat file, which represents system limits for various floating-point types
n Numeric literals of various floating-point types
n C++’s arithmetic operators
n Automatic type conversions
n Forced type conversions (type casts)
The essence of object-oriented programming (OOP) is designing and extending your own data types. Designing your own data types represents an effort to make a type match the data. If you do this properly, you’ll find it much simpler to work with the data later. But before you can create your own types, you must know and understand the types that are built in to C++ because those types will be your building blocks. The built-in C++ types come in two groups: fundamental types and compound types. In this chapter you’ll meet the fundamental types, which represent integers and floatingpoint numbers.That might sound like just two types; however, C++ recognizes that no one integer type and no one floating-point type match all programming requirements, so it offers several variants on these two data themes. Chapter 4,“Compound Types,” follows up by covering several types that are built on the basic types; these additional compound types include arrays, strings, pointers, and structures.


66 Chapter 3 Dealing with Data
Of course, a program also needs a means to identify stored data. In this chapter you’ll examine one method for doing so—using variables.Then you’ll look at how to do arithmetic in C++. Finally, you’ll see how C++ converts values from one type to another.
Simple Variables
Programs typically need to store information—perhaps the current price of Google stock, the average humidity in New York City in August, the most common letter in the U.S. Constitution and its relative frequency, or the number of available Elvis impersonators.To store an item of information in a computer, the program must keep track of three fundamental properties:
n Where the information is stored
n What value is kept there
n What kind of information is stored
The strategy the examples in this book have used so far is to declare a variable.The type used in the declaration describes the kind of information, and the variable name represents the value symbolically. For example, suppose Chief Lab Assistant Igor uses the following statements:
int braincount;
braincount = 5;
These statements tell the program that it is storing an integer and that the name braincount represents the integer’s value, 5 in this case. In essence, the program locates a chunk of memory large enough to hold an integer, notes the location, and copies the value 5 into the location.You then can use braincount later in your program to access that memory location.These statements don’t tell you (or Igor) where in memory the value is stored, but the program does keep track of that information, too. Indeed, you can use the & operator to retrieve braincount’s address in memory.You’ll learn about that operator in the next chapter, when you investigate a second strategy for identifying data—using pointers.
Names for Variables
C++ encourages you to use meaningful names for variables. If a variable represents the cost of a trip, you should call it cost_of_trip or costOfTrip, not just x or cot.You do have to follow a few simple C++ naming rules:
n The only characters you can use in names are alphabetic characters, numeric digits, and the underscore (_) character.
n The first character in a name cannot be a numeric digit.
n Uppercase characters are considered distinct from lowercase characters.


67
Simple Variables
n You can’t use a C++ keyword for a name.
n Names beginning with two underscore characters or with an underscore character followed by an uppercase letter are reserved for use by the implementation—that is, the compiler and the resources it uses. Names beginning with a single underscore character are reserved for use as global identifiers by the implementation.
n C++ places no limits on the length of a name, and all characters in a name are significant. However, some platforms might have their own length limits.
The next-to-last point is a bit different from the preceding points because using a name such as __time_stop or _Donut doesn’t produce a compiler error; instead, it leads to undefined behavior. In other words, there’s no telling what the result will be.The reason there is no compiler error is that the names are not illegal but rather are reserved for the implementation to use.The bit about global names refers to where the names are declared; Chapter 4 touches on that topic. The final point differentiates C++ from ANSI C (C99), which guarantees only that the first 63 characters in a name are significant. (In ANSI C, two names that have the same first 63 characters are considered identical, even if the 64th characters differ.) Here are some valid and invalid C++ names:
int poodle; // valid
int Poodle; // valid and distinct from poodle
int POODLE; // valid and even more distinct
Int terrier; // invalid -- has to be int, not Int
int my_stars3 // valid
int _Mystars3; // valid but reserved -- starts with underscore
int 4ever; // invalid because starts with a digit
int double; // invalid -- double is a C++ keyword
int begin; // valid -- begin is a Pascal keyword
int __fools; // valid but reserved -- starts with two underscores
int the_very_best_variable_i_can_be_version_112; // valid
int honky-tonk; // invalid -- no hyphens allowed
If you want to form a name from two or more words, the usual practice is to separate the words with an underscore character, as in my_onions, or to capitalize the initial character of each word after the first, as in myEyeTooth. (C veterans tend to use the underscore method in the C tradition, whereas those raised in the Pascal tradition prefer the capitalization approach.) Either form makes it easier to see the individual words and to
distinguish between, say, carDrip and cardRip, or boat_sport and boats_port.
Naming Schemes
Schemes for naming variables, like schemes for naming functions, provide fertile ground for fervid discussion. Indeed, this topic produces some of the most strident disagreements in programming. Again, as with function names, the C++ compiler doesn’t care about your variable names as long as they satisfy the rules, but a consistent, precise personal naming convention will serve you well.


68 Chapter 3 Dealing with Data
As in function naming, capitalization is a key issue in variable naming (see the sidebar “Naming Conventions” in Chapter 2, “Setting Out to C++”), but many programmers may insert an additional level of information in a variable name—a prefix that describes the variable’s type or contents. For instance, the integer myWeight might be named nMyWeight; here, the n prefix is used to represent an integer value, which is useful when you are reading code and the definition of the variable isn’t immediately at hand. Alternatively, this variable might be named intMyWeight, which is more precise and legible, although it does include a couple extra letters (anathema to many programmers). Other prefixes are commonly used in like fashion: str or sz might be used to represent a null-terminated string of characters, b might represent a Boolean value, p a pointer, c a single character.
As you progress into the world of C++, you will find many examples of the prefix naming style (including the handsome m_lpctstr prefix—a class member value that contains a long pointer to a constant, null-terminated string of characters), as well as other, more bizarre and possibly counterintuitive styles that you may or may not adopt as your own. As in all the stylistic, subjective parts of C++, consistency and precision are best. You should use variable names to fit your own needs, preferences, and personal style. (Or, if required, choose names that fit the needs, preferences, and personal style of your employer.)
Integer Types
Integers are numbers with no fractional part, such as 2, 98, –5286, and 0.There are lots of integers, assuming that you consider an infinite number to be a lot, so no finite amount of computer memory can represent all possible integers.Thus, a language can represent only a subset of all integers. Some languages offer just one integer type (one type fits all!), but C++ provides several choices.This gives you the option of choosing the integer type that best meets a program’s particular requirements.This concern with matching type to data presages the designed data types of OOP. The various C++ integer types differ in the amount of memory they use to hold an integer.A larger block of memory can represent a larger range in integer values.Also some types (signed types) can represent both positive and negative values, whereas others (unsigned types) can’t represent negative values.The usual term for describing the amount of memory used for an integer is width.The more memory a value uses, the wider it is. C++’s basic integer types, in order of increasing width, are char, short, int, long, and, with C++11, long long. Each comes in both signed and unsigned versions.That gives you a choice of ten different integer types! Let’s look at these integer types in more detail. Because the char type has some special properties (it’s most often used to represent characters instead of numbers), this chapter covers the other types first.
The short, int, long, and long long Integer Types
Computer memory consists of units called bits. (See the “Bits and Bytes” sidebar later in this chapter.) By using different numbers of bits to store values, the C++ types short, int, long, and long long can represent up to four different integer widths. It would be convenient if each type were always some particular width for all systems—for example, if short were always 16 bits, int were always 32 bits, and so on. But life is not that simple.


69
Simple Variables
No one choice is suitable for all computer designs. C++ offers a flexible standard with some guaranteed minimum sizes, which it takes from C. Here’s what you get:
n A short integer is at least 16 bits wide.
n An int integer is at least as big as short.
n A long integer is at least 32 bits wide and at least as big as int.
n A long long integer is at least 64 bits wide and at least as big as long.
Bits and Bytes
The fundamental unit of computer memory is the bit. Think of a bit as an electronic switch that you can set to either off or on. Off represents the value 0, and on represents the value 1. An 8-bit chunk of memory can be set to 256 different combinations. The number 256 comes from the fact that each bit has two possible settings, making the total number of combinations for 8 bits 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2, or 256. Thus, an 8-bit unit can represent, say, the values 0 through 255 or the values –128 through 127. Each additional bit doubles the number of combinations. This means you can set a 16-bit unit to 65,536 different values, a 32-bit unit to 4,294,672,296 different values, and a 64-bit unit to 18,446,744,073,709,551,616 different values. As a point of comparison, unsigned long can’t hold the Earth’s current population or the number of stars in our galaxy, but long long can.
A byte usually means an 8-bit unit of memory. Byte in this sense is the unit of measurement that describes the amount of memory in a computer, with a kilobyte equal to 1,024 bytes and a megabyte equal to 1,024 kilobytes. However, C++ defines byte differently. The C++ byte consists of at least enough adjacent bits to accommodate the basic character set for the implementation. That is, the number of possible values must equal or exceed the number of distinct characters. In the United States, the basic character sets are usually the ASCII and EBCDIC sets, each of which can be accommodated by 8 bits, so the C++ byte is typically 8 bits on systems using those character sets. However, international programming can require much larger character sets, such as Unicode, so some implementations may use a 16-bit byte or even a 32-bit byte. Some use the term octet to denote an 8-bit byte.
Many systems currently use the minimum guarantee, making short 16 bits and long 32 bits.This still leaves several choices open for int. It could be 16, 24, or 32 bits in width and meet the standard. It could even be 64 bits, providing that long and long long are at least that wide.Typically, int is 16 bits (the same as short) for older IBM PC implementations and 32 bits (the same as long) for Windows XP,WindowsVista,Windows 7, Macintosh OS X,VAX, and many other minicomputer implementations. Some implementations give you a choice of how to handle int. (What does your implementation use? The next example shows you how to determine the limits for your system without your having to open a manual.) The differences between implementations for type widths can cause problems when you move a C++ program from one environment to another, including using a different compiler on the same system. But a little care, as discussed later in this chapter, can minimize those problems.


70 Chapter 3 Dealing with Data
You use these type names to declare variables just as you would use int:
short score; // creates a type short integer variable
int temperature; // creates a type int integer variable
long position; // creates a type long integer variable
Actually, short is short for short int and long is short for long int, but hardly anyone uses the longer forms. The four types—int, short, long, and long long—are signed types, meaning each splits its range approximately equally between positive and negative values. For example, a 16-bit int might run from –32,768 to +32,767. If you want to know how your system’s integers size up, you can use C++ tools to investigate type sizes with a program. First, the sizeof operator returns the size, in bytes, of a type or a variable. (An operator is a built-in language element that operates on one or more items to produce a value. For example, the addition operator, represented by +, adds two values.) Recall that the meaning of byte is implementation dependent, so a 2-byte int could be 16 bits on one system and 32 bits on another. Second, the climits header file (or, for older implementations, the limits.h header file) contains information about integer type limits. In particular, it defines symbolic names to represent different limits. For example, it defines INT_MAX as the largest possible int value and CHAR_BIT as the number of bits in a byte. Listing 3.1 demonstrates how to use these facilities.The program also illustrates initialization, which is the use of a declaration statement to assign a value to a variable.
Listing 3.1 limits.cpp
// limits.cpp -- some integer limits
#include <iostream>
#include <climits> // use limits.h for older systems
int main()
{
using namespace std;
int n_int = INT_MAX; // initialize n_int to max int value
short n_short = SHRT_MAX; // symbols defined in climits file
long n_long = LONG_MAX;
long long n_llong = LLONG_MAX;
// sizeof operator yields size of type or of variable
cout << "int is " << sizeof (int) << " bytes." << endl;
cout << "short is " << sizeof n_short << " bytes." << endl;
cout << "long is " << sizeof n_long << " bytes." << endl;
cout << "long long is " << sizeof n_llong << " bytes." << endl;
cout << endl;
cout << "Maximum values:" << endl;
cout << "int: " << n_int << endl;
cout << "short: " << n_short << endl;


71
Simple Variables
cout << "long: " << n_long << endl;
cout << "long long: " << n_llong << endl << endl;
cout << "Minimum int value = " << INT_MIN << endl;
cout << "Bits per byte = " << CHAR_BIT << endl;
return 0;
}
Note
If your system doesn’t support the long long type, you should remove the lines using that type.
Here is sample output from the program in Listing 3.1:
int is 4 bytes.
short is 2 bytes.
long is 4 bytes.
long long is 8 bytes.
Maximum values:
int: 2147483647
short: 32767
long: 2147483647
long long: 9223372036854775807
Minimum int value = -2147483648
Bits per byte = 8
These particular values came from a system running 64-bit Windows 7. The following sections look at the chief programming features for this program.
The sizeof Operator and the climits Header File
The sizeof operator reports that int is 4 bytes on the base system, which uses an 8-bit byte.You can apply the sizeof operator to a type name or to a variable name.When you use the sizeof operator with a type name, such as int, you enclose the name in parentheses. But when you use the operator with the name of the variable, such as n_short, parentheses are optional:
cout << "int is " << sizeof (int) << " bytes.\n";
cout << "short is " << sizeof n_short << " bytes.\n";
The climits header file defines symbolic constants (see the sidebar,“Symbolic Constants the Preprocessor Way,” later in this chapter) to represent type limits.As mentioned previously, INT_MAX represents the largest value type int can hold; this turned out to be 2,147,483,647 for our Windows 7 system.The compiler manufacturer provides a climits file that reflects the values appropriate to that compiler. For example, the climits file for some older systems that used a 16-bit int, defines INT_MAX to represent 32,767.Table 3.1


72 Chapter 3 Dealing with Data
Table 3.1 Symbolic Constants from climits
Symbolic Constant Represents
CHAR_BIT Number of bits in a char
CHAR_MAX Maximum char value
CHAR_MIN Minimum char value
SCHAR_MAX Maximum signed char value
SCHAR_MIN Minimum signed char value
UCHAR_MAX Maximum unsigned char value
SHRT_MAX Maximum short value
SHRT_MIN Minimum short value
USHRT_MAX Maximum unsigned short value
INT_MAX Maximum int value
INT_MIN Minimum int value
UINT_MAX Maximum unsigned int value
LONG_MAX Maximum long value
LONG_MIN Minimum long value
ULONG_MAX Maximum unsigned long value
LLONG_MAX Maximum long long value
LLONG_MIN Minimum long long value
ULLONG_MAX Maximum unsigned long long value
summarizes the symbolic constants defined in the climits file; some pertain to types you have not yet learned.
Symbolic Constants the Preprocessor Way
The climits file contains lines similar to the following:
#define INT_MAX 32767
Recall that the C++ compilation process first passes the source code through a preprocessor. Here #define, like #include, is a preprocessor directive. What this particular directive tells the preprocessor is this: Look through the program for instances of INT_MAX and replace each occurrence with 32767. So the #define directive works like a global searchand-replace command in a text editor or word processor. The altered program is compiled after these replacements occur. The preprocessor looks for independent tokens (separate words) and skips embedded words. That is, the preprocessor doesn’t replace PINT_MAXIM


73
Simple Variables
Initialization
Initialization combines assignment with declaration. For example, the following statement declares the n_int variable and sets it to the largest possible type int value:
int n_int = INT_MAX;
You can also use literal constants, such as 255, to initialize values.You can initialize a variable to another variable, provided that the other variable has been defined first.You can even initialize a variable to an expression, provided that all the values in the expression are known when program execution reaches the declaration:
int uncles = 5; // initialize uncles to 5
int aunts = uncles; // initialize aunts to 5
int chairs = aunts + uncles + 4; // initialize chairs to 14
Moving the uncles declaration to the end of this list of statements would invalidate the other two initializations because then the value of uncles wouldn’t be known at the time the program tries to initialize the other variables. The initialization syntax shown previously comes from C; C++ has an initialization syntax that is not shared with C:
int owls = 101; // traditional C initialization, sets owls to 101
int wrens(432); // alternative C++ syntax, set wrens to 432
Caution
If you don’t initialize a variable that is defined inside a function, the variable’s value is indeterminate. That means the value is whatever happened to be sitting at that memory location prior to the creation of the variable.
with P32767IM. You can use #define to define your own symbolic constants, too (see Listing 3.2). However, the #define directive is a C relic. C++ has a better way of creating symbolic constants (using the const keyword, discussed in a later section), so you won’t be using #define much. But some header files, particularly those designed to be used with both C and C++, do use it.
If you know what the initial value of a variable should be, initialize it.True, separating the declaring of a variable from assigning it a value can create momentary suspense:
short year; // what could it be?
year = 1492; // oh
But initializing the variable when you declare it protects you from forgetting to assign the value later.


74 Chapter 3 Dealing with Data
Initialization with C++11
There’s another format for initialization that’s used with arrays and structures but in C++98 can also be used with single-valued variables:
int hamburgers = {24}; // set hamburgers to 24
Using a braced initializer for a single-valued variable hasn’t been particularly common, but the C++11 standard is extending it some ways. First, it can be used with or without the = sign:
int emus{7}; // set emus to 5
int rheas = {12}; // set rheas to 12
Second, the braces can be left empty, in which case the variable is initialized to 0:
int rocs = {}; // set rocs to 0
int psychics{}; // set psychics to 0
Third, it provides better protection against type conversion errors, a topic we’ll return to near the end of this chapter. Why, you may ask with good reason, does the language need more alternatives? As odd as it may seem, the reason is to make using C++ easier for the novice. In the past, C++ has used different forms of initialization for different types, and the form used to initialize class variables was different from the form used for ordinary structures—and that, in turn, was different from the form usually used for simple variables such as we have been using. C++ added the parentheses form of initialization to make initializing ordinary variables more like initializing class variables. C++11 makes it possible to use the braces syntax (with or without the =) with all types—a universal initialization syntax. In the future, texts may introduce you to initialization using the brace forms and mention the other forms as historical oddities retained for backward compatibility.
Unsigned Types
Each of the four integer types you just learned about comes in an unsigned variety that can’t hold negative values.This has the advantage of increasing the largest value the variable can hold. For example, if short represents the range –32,768 to +32,767, the unsigned version can represent the range 0 to 65,535. Of course, you should use unsigned types only for quantities that are never negative, such as populations, bean counts, and happy face manifestations.To create unsigned versions of the basic integer types, you just use the keyword unsigned to modify the declarations:
unsigned short change; // unsigned short type
unsigned int rovert; // unsigned int type
unsigned quarterback; // also unsigned int
unsigned long gone; // unsigned long type
unsigned long long lang_lang; // unsigned long long type
Note that unsigned by itself is short for unsigned int.


75
Simple Variables
Listing 3.2 illustrates the use of unsigned types. It also shows what might happen if your program tries to go beyond the limits for integer types. Finally, it gives you one last look at the preprocessor #define statement.
Listing 3.2 exceed.cpp
// exceed.cpp -- exceeding some integer limits
#include <iostream>
#define ZERO 0 // makes ZERO symbol for 0 value
#include <climits> // defines INT_MAX as largest int value
int main()
{
using namespace std;
short sam = SHRT_MAX; // initialize a variable to max value
unsigned short sue = sam;// okay if variable sam already defined
cout << "Sam has " << sam << " dollars and Sue has " << sue;
cout << " dollars deposited." << endl
<< "Add $1 to each account." << endl << "Now ";
sam = sam + 1;
sue = sue + 1;
cout << "Sam has " << sam << " dollars and Sue has " << sue;
cout << " dollars deposited.\nPoor Sam!" << endl;
sam = ZERO;
sue = ZERO;
cout << "Sam has " << sam << " dollars and Sue has " << sue;
cout << " dollars deposited." << endl;
cout << "Take $1 from each account." << endl << "Now ";
sam = sam - 1;
sue = sue - 1;
cout << "Sam has " << sam << " dollars and Sue has " << sue;
cout << " dollars deposited." << endl << "Lucky Sue!" << endl;
return 0;
}
Here’s the output from the program in Listing 3.2:
Sam has 32767 dollars and Sue has 32767 dollars deposited.
Add $1 to each account.
Now Sam has -32768 dollars and Sue has 32768 dollars deposited.
Poor Sam!
Sam has 0 dollars and Sue has 0 dollars deposited.
Take $1 from each account.
Now Sam has -1 dollars and Sue has 65535 dollars deposited.
Lucky Sue!


76 Chapter 3 Dealing with Data
signed integer
increasing size
reset point
+32767
-16384 +16384
–32768
–1 0 +1
unsigned integer
increasing size
+32767
+49152 +16364
+32768
+65535 0 +1
reset point
Figure 3.1 Typical overflow behavior for integers.
The program sets a short variable (sam) and an unsigned short variable (sue) to the largest short value, which is 32,767 on our system.Then it adds 1 to each value.This causes no problems for sue because the new value is still much less than the maximum value for an unsigned integer. But sam goes from 32,767 to –32,768! Similarly, subtracting 1 from 0 creates no problems for sam, but it makes the unsigned variable sue go from 0 to 65,535.As you can see, these integers behave much like an odometer. If you go past the limit, the values just start over at the other end of the range (see Figure 3.1). C++ guarantees that unsigned types behave in this fashion. However, C++ doesn’t guarantee that signed integer types can exceed their limits (overflow and underflow) without complaint, but that is the most common behavior on current implementations.
Choosing an Integer Type
With the richness of C++ integer types, which should you use? Generally, int is set to the most “natural” integer size for the target computer. Natural size refers to the integer form that the computer handles most efficiently. If there is no compelling reason to choose another type, you should use int. Now look at reasons why you might use another type. If a variable represents something that is never negative, such as the number of words in a document, you can use an unsigned type; that way the variable can represent higher values.


77
Simple Variables
// myprofit.cpp ... int receipts = 560334; long also = 560334; cout << receipts << "\n"; cout << also << "\n"; ...
// myprofit.cpp ... int receipts = 560334; long also = 560334; cout << receipts << "\n"; cout << also << "\n"; ...
560334 560334
-29490 560334
Type int worked on this computer. Type int failed on this computer.
Figure 3.2 For portability, use long for big integers.
If you know that the variable might have to represent integer values too great for a 16bit integer, you should use long.This is true even if int is 32 bits on your system.That way, if you transfer your program to a system with a 16-bit int, your program won’t embarrass you by suddenly failing to work properly (see Figure 3.2).And if a mere two billion is inadequate for your needs, you can move up to long long.
Using short can conserve memory if short is smaller than int. Most typically, this is important only if you have a large array of integers. (An array is a data structure that stores several values of the same type sequentially in memory.) If it is important to conserve space, you should use short instead of int, even if the two are the same size. Suppose, for example, that you move your program from a 16-bit int system to a 32-bit int system. That doubles the amount of memory needed to hold an int array, but it doesn’t affect the requirements for a short array. Remember, a bit saved is a bit earned. If you need only a single byte, you can use char.We’ll examine that possibility soon.


78 Chapter 3 Dealing with Data
Integer Literals
An integer literal, or constant, is one you write out explicitly, such as 212 or 1776. C++, like C, lets you write integers in three different number bases: base 10 (the public favorite), base 8 (the old Unix favorite), and base 16 (the hardware hacker’s favorite). Appendix A,“Number Bases,” describes these bases; here we’ll look at the C++ representations. C++ uses the first digit or two to identify the base of a number constant. If the first digit is in the range 1–9, the number is base 10 (decimal); thus 93 is base 10. If the first digit is 0 and the second digit is in the range 1–7, the number is base 8 (octal); thus 042 is octal and equal to 34 decimal. If the first two characters are 0x or 0X, the number is base 16 (hexadecimal); thus 0x42 is hex and equal to 66 decimal. For hexadecimal values, the characters a–f and A–F represent the hexadecimal digits corresponding to the values 10–15. 0xF is 15 and 0xA5 is 165 (10 sixteens plus 5 ones). Listing 3.3 is tailor-made to show the three bases.
Listing 3.3 hexoct1.cpp
// hexoct1.cpp -- shows hex and octal literals
#include <iostream>
int main()
{
using namespace std;
int chest = 42; // decimal integer literal
int waist = 0x42; // hexadecimal integer literal
int inseam = 042; // octal integer literal
cout << "Monsieur cuts a striking figure!\n";
cout << "chest = " << chest << " (42 in decimal)\n";
cout << "waist = " << waist << " (0x42 in hex)\n";
cout << "inseam = " << inseam << " (042 in octal)\n";
return 0;
}
By default, cout displays integers in decimal form, regardless of how they are written in a program, as the following output shows:
Monsieur cuts a striking figure!
chest = 42 (42 in decimal)
waist = 66 (0x42 in hex)
inseam = 34 (042 in octal)
Keep in mind that these notations are merely notational conveniences. For example, if you belong to a vintage PC club and read that the CGA video memory segment is B000 in hexadecimal, you don’t have to convert the value to base 10 45,056 before using it in your program. Instead, you can simply use 0xB000. But whether you write the value ten as 10, 012, or 0xA, it’s stored the same way in the computer—as a binary (base 2) value.


79
Simple Variables
By the way, if you want to display a value in hexadecimal or octal form, you can use some special features of cout. Recall that the iostream header file provides the endl manipulator to give cout the message to start a new line. Similarly, it provides the dec, hex, and oct manipulators to give cout the messages to display integers in decimal, hexadecimal, and octal formats, respectively. Listing 3.4 uses hex and oct to display the decimal value 42 in three formats. (Decimal is the default format, and each format stays in effect until you change it.)
Listing 3.4 hexoct2.cpp
// hexoct2.cpp -- display values in hex and octal
#include <iostream>
using namespace std;
int main()
{
using namespace std;
int chest = 42;
int waist = 42;
int inseam = 42;
cout << "Monsieur cuts a striking figure!" << endl;
cout << "chest = " << chest << " (decimal for 42)" << endl;
cout << hex; // manipulator for changing number base
cout << "waist = " << waist << " (hexadecimal for 42)" << endl;
cout << oct; // manipulator for changing number base
cout << "inseam = " << inseam << " (octal for 42)" << endl;
return 0;
}
Here’s the program output for Listing 3.4:
Monsieur cuts a striking figure!
chest = 42 (decimal for 42)
waist = 2a (hexadecimal for 42)
inseam = 52 (octal for 42)
Note that code like the following doesn’t display anything onscreen:
cout << hex;
Instead, it changes the way cout displays integers.Thus, the manipulator hex is really a message to cout that tells it how to behave.Also note that because the identifier hex is part of the std namespace and the program uses that namespace, this program can’t use hex as the name of a variable. However, if you omitted the using directive and instead
used std::cout, std::endl, std::hex, and std::oct, you could still use plain hex as the name for a variable.


80 Chapter 3 Dealing with Data
How C++ Decides What Type a Constant Is
A program’s declarations tell the C++ compiler the type of a particular integer variable. But what about constants? That is, suppose you represent a number with a constant in a program:
cout << "Year = " << 1492 << "\n";
Does the program store 1492 as an int, a long, or some other integer type? The answer is that C++ stores integer constants as type int unless there is a reason to do otherwise.Two such reasons are if you use a special suffix to indicate a particular type or if a value is too large to be an int. First, look at the suffixes.These are letters placed at the end of a numeric constant to indicate the type.An l or L suffix on an integer means the integer is a type long constant, a u or U suffix indicates an unsigned int constant, and ul (in any combination of orders and uppercase and lowercase) indicates a type unsigned long constant. (Because a lowercase l can look much like the digit 1, you should use the uppercase L for suffixes.) For example, on a system using a 16-bit int and a 32-bit long, the number 22022 is stored in 16 bits as an int, and the number 22022L is stored in 32 bits as a long. Similarly, 22022LU and 22022UL are unsigned long. C++11 provides the ll and LL suffixes for type long
long, and ull, Ull, uLL, and ULL for unsigned long long.
Next, look at size. C++ has slightly different rules for decimal integers than it has for hexadecimal and octal integers. (Here decimal means base 10, just as hexadecimal means base 16; the term decimal does not necessarily imply a decimal point.) A decimal integer without a suffix is represented by the smallest of the following types that can hold it: int, long, or long long. On a computer system using a 16-bit int and a 32-bit long, 20000 is represented as type int, 40000 is represented as long, and 3000000000 is represented as long long. A hexadecimal or octal integer without a suffix is represented by the smallest of the following types that can hold it: int, unsigned int, long, unsigned long, long long, or unsigned long long.The same computer system that represents 40000 as long represents the hexadecimal equivalent 0x9C40 as an unsigned int.That’s because hexadecimal is frequently used to express memory addresses, which intrinsically are unsigned. So unsigned int is more appropriate than long for a 16-bit address.
The char Type: Characters and Small Integers
It’s time to turn to the final integer type: char.As you probably suspect from its name, the char type is designed to store characters, such as letters and numeric digits. Now, whereas storing numbers is no big deal for computers, storing letters is another matter. Programming languages take the easy way out by using number codes for letters.Thus, the char type is another integer type. It’s guaranteed to be large enough to represent the entire range of basic symbols—all the letters, digits, punctuation, and the like—for the target computer system. In practice, many systems support fewer than 128 kinds of characters, so a single byte can represent the whole range.Therefore, although char is most often used to handle characters, you can also use it as an integer type that is typically smaller than short.


81
Simple Variables
The most common symbol set in the United States is the ASCII character set, described in Appendix C,“The ASCII Character Set.”A numeric code (the ASCII code) represents each character in the set. For example, 65 is the code for the character A, and 77 is the code for the character M. For convenience, this book assumes ASCII code in its examples. However, a C++ implementation uses whatever code is native to its host system—for example, EBCDIC (pronounced “eb-se-dik”) on an IBM mainframe. Neither ASCII nor EBCDIC serve international needs that well, and C++ supports a wide-character type that can hold a larger range of values, such as are used by the international Unicode character set.You’ll learn about this wchar_t type later in this chapter. Try the char type in Listing 3.5.
Listing 3.5 chartype.cpp
// chartype.cpp -- the char type
#include <iostream>
int main( )
{
using namespace std;
char ch; // declare a char variable
cout << "Enter a character: " << endl;
cin >> ch;
cout << "Hola! ";
cout << "Thank you for the " << ch << " character." << endl;
return 0;
}
Here’s the output from the program in Listing 3.5:
Enter a character:
M
Hola! Thank you for the M character.
The interesting thing is that you type an M, not the corresponding character code, 77. Also the program prints an M, not 77.Yet if you peer into memory, you find that 77 is the value stored in the ch variable.The magic, such as it is, lies not in the char type but in cin and cout.These worthy facilities make conversions on your behalf. On input, cin converts the keystroke input M to the value 77. On output, cout converts the value 77 to the displayed character M; cin and cout are guided by the type of variable. If you place the same value 77 into an int variable, cout displays it as 77. (That is, cout displays two 7 characters.) Listing 3.6 illustrates this point. It also shows how to write a character literal in C++: Enclose the character within two single quotation marks, as in 'M'. (Note that the example doesn’t use double quotation marks. C++ uses single quotation marks for a character and double quotation marks for a string.The cout object can handle either, but, as Chapter 4 discusses, the two are quite different from one another.) Finally, the program introduces a cout feature, the cout.put() function, which displays a single character.


82 Chapter 3 Dealing with Data
Listing 3.6 morechar.cpp
// morechar.cpp -- the char type and int type contrasted
#include <iostream>
int main()
{
using namespace std;
char ch = 'M'; // assign ASCII code for M to ch
int i = ch; // store same code in an int
cout << "The ASCII code for " << ch << " is " << i << endl;
cout << "Add one to the character code:" << endl;
ch = ch + 1; // change character code in ch
i = ch; // save new character code in i
cout << "The ASCII code for " << ch << " is " << i << endl;
// using the cout.put() member function to display a char
cout << "Displaying char ch using cout.put(ch): ";
cout.put(ch);
// using cout.put() to display a char constant
cout.put('!');
cout << endl << "Done" << endl;
return 0;
}
Here is the output from the program in Listing 3.6:
The ASCII code for M is 77
Add one to the character code:
The ASCII code for N is 78
Displaying char ch using cout.put(ch): N!
Done
Program Notes
In the program in Listing 3.6, the notation 'M' represents the numeric code for the M character, so initializing the char variable ch to 'M' sets ch to the value 77.The program then assigns the identical value to the int variable i, so both ch and i have the value 77. Next, cout displays ch as M and i as 77. As previously stated, a value’s type guides cout as it chooses how to display that value—just another example of smart objects. Because ch is really an integer, you can apply integer operations to it, such as adding 1. This changes the value of ch to 78.The program then resets i to the new value. (Equivalently, you can simply add 1 to i.) Again, cout displays the char version of that value as a character and the int version as a number.


83
Simple Variables
The fact that C++ represents characters as integers is a genuine convenience that makes it easy to manipulate character values.You don’t have to use awkward conversion functions to convert characters to ASCII and back. Even digits entered via the keyboard are read as characters. Consider the following sequence:
char ch;
cin >> ch;
If you type 5 and Enter, this code reads the 5 character and stores the character code for the 5 character (53 in ASCII) in ch. Now consider this code:
int n;
cin >> n;
The same input results in the program reading the 5 character and running a routine converting the character to the corresponding numeric value of 5, which gets stored in n. Finally, the program uses the cout.put() function to display both c and a character constant.
A Member Function: cout.put()
Just what is cout.put(), and why does it have a period in its name? The cout.put() function is your first example of an important C++ OOP concept, the member function. Remember that a class defines how to represent data and how to manipulate it.A member function belongs to a class and describes a method for manipulating class data.The ostream class, for example, has a put() member function that is designed to output characters.You can use a member function only with a particular object of that class, such as the cout object, in this case.To use a class member function with an object such as cout, you use a period to combine the object name (cout) with the function name (put()). The period is called the membership operator.The notation cout.put() means to use the class member function put() with the class object cout.You’ll learn about this in greater detail when you reach classes in Chapter 10,“Objects and Classes.” Now the only classes you have are the istream and ostream classes, and you can experiment with their member functions to get more comfortable with the concept. The cout.put() member function provides an alternative to using the << operator to display a character.At this point you might wonder why there is any need for cout.put(). Much of the answer is historical. Before Release 2.0 of C++, cout would display character variables as characters but display character constants, such as 'M' and 'N', as numbers.The problem was that earlier versions of C++, like C, stored character constants as type int.That is, the code 77 for 'M' would be stored in a 16-bit or 32-bit unit. Meanwhile, char variables typically occupied 8 bits.A statement like the following copied 8 bits (the important 8 bits) from the constant 'M' to the variable ch:
char ch = 'M';


84 Chapter 3 Dealing with Data
Unfortunately, this meant that, to cout, 'M' and ch looked quite different from one another, even though both held the same value. So a statement like the following would print the ASCII code for the $ character rather than simply display $:
cout << '$';
But the following would print the character, as desired:
cout.put('$');
Now, after Release 2.0, C++ stores single-character constants as type char, not type int.Therefore, cout now correctly handles character constants. The cin object has a couple different ways of reading characters from input.You can explore these by using a program that uses a loop to read several characters, so we’ll return to this topic when we cover loops in Chapter 5,“Loops and Relational Expressions.”
char Literals
You have several options for writing character literals in C++.The simplest choice for ordinary characters, such as letters, punctuation, and digits, is to enclose the character in single quotation marks.This notation stands for the numeric code for the character. For example, an ASCII system has the following correspondences:
n 'A' is 65, the ASCII code for A.
n 'a' is 97, the ASCII code for a.
n '5' is 53, the ASCII code for the digit 5.
n ' ' is 32, the ASCII code for the space character.
n '!' is 33, the ASCII code for the exclamation point.
Using this notation is better than using the numeric codes explicitly. It’s clearer, and it doesn’t assume a particular code. If a system uses EBCDIC, then 65 is not the code for A, but 'A' still represents the character. There are some characters that you can’t enter into a program directly from the keyboard. For example, you can’t make the newline character part of a string by pressing the Enter key; instead, the program editor interprets that keystroke as a request for it to start a new line in your source code file. Other characters have difficulties because the C++ language imbues them with special significance. For example, the double quotation mark character delimits string literals, so you can’t just stick one in the middle of a string literal. C++ has special notations, called escape sequences, for several of these characters, as shown in Table 3.2. For example, \a represents the alert character, which beeps your terminal’s speaker or rings its bell.The escape sequence \n represents a newline.And \" represents the double quotation mark as an ordinary character instead of a string delimiter.You can use these notations in strings or in character constants, as in the following examples:


85
Simple Variables
Table 3.2 C++ Escape Sequence Codes
Character Name
ASCII Symbol
C++ Code
ASCII Decimal Code ASCII Hex Code
Newline NL (LF) \n 10 0xA
Horizontal tab HT \t 9 0x9
Vertical tab VT \v 11 0xB
Backspace BS \b 8 0x8
Carriage return CR \r 13 0xD
Alert BEL \a 7 0x7
Backslash \ \\ 92 0x5C
Question mark ? \? 63 0x3F
Single quote ’ \' 39 0x27
Double quote ” \" 34 0x22
char alarm = '\a';
cout << alarm << "Don't do that again!\a\n";
cout << "Ben \"Buggsie\" Hacker\nwas here!\n";
The last line produces the following output:
Ben "Buggsie" Hacker
was here!
Note that you treat an escape sequence, such as \n, just as a regular character, such as Q. That is, you enclose it in single quotes to create a character constant and don’t use single quotes when including it as part of a string. The escape sequence concept dates back to when people communicated with computers using the teletype, an electromechanical typewriter-printer, and modern systems don’t always honor the complete set of escape sequences. For example, some systems remain silent for the alarm character. The newline character provides an alternative to endl for inserting new lines into output.You can use the newline character in character constant notation ('\n') or as character in a string ("\n").All three of the following move the screen cursor to the beginning of the next line:
cout << endl; // using the endl manipulator
cout << '\n'; // using a character constant
cout << "\n"; // using a string
You can embed the newline character in a longer string; this is often more convenient than using endl. For example, the following two cout statements produce the same output:
cout << endl << endl << "What next?" << endl << "Enter a number:" << endl;
cout << "\n\nWhat next?\nEnter a number:\n";