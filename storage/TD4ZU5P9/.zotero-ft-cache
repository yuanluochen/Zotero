第 1 章 ROS2 概述与环境搭建
1.1 ROS2 简介
1.1.1 ROS2 发展历程
1.1.2 ROS2 组成体系
1.1.3 ROS2 优势
1.2 ROS2 安装
1.2.1 安装 ROS2
1.2.2 测试 ROS2
1.2.3 安装 colcon 构建工具
1.3 ROS2 快速体验
1.3.1 案例简介
1.3.2 HelloWorld(C++)
1.3.3 HelloWorld(Python)
1.3.4 运行优化
1.4 ROS2 集成开发环境搭建
1.4.1 安装 VSCode
1.4.2 安装终端
1.4.3 安装 git
1.5 ROS2 体系框架
1.5.1 ROS2 文件系统
1.5.2 ROS2 核心模块
1.5.3 ROS2 技术支持
1.5.4 ROS2 应用方向


1.6 本章小结
第 2 章 ROS2 通信机制核心
2.1 通信机制简介
2.2 话题通信
2.2.1 案例以及案例分析
2.2.2 话题通信之原生消息(C++)
2.2.3 话题通信之原生消息(Python)
2.2.4 话题通信自定义接口消息
2.2.5 话题通信之自定义消息(C++)
2.2.6 话题通信之自定义消息(Python)
2.3 服务通信
2.3.1 案例以及案例分析
2.3.2 服务通信接口消息
2.3.3 服务通信(C++)
2.3.4 服务通信(Python)
2.4 动作通信
2.4.1 案例以及案例分析
2.4.2 动作通信接口消息
2.4.3 动作通信(C++)
2.4.4 动作通信(Python)
2.5 参数服务
2.5.1 案例以及案例分析
2.5.2 参数数据类型


2.5.3 参数服务(C++)
2.5.4 参数服务(Python)
2.6 本章小结
第 3 章 ROS2 通信机制补充
3.1 分布式
3.2 工作空间覆盖
3.3 元功能包
3.4 节点重名
3.4.1 ros2 run 设置节点名称
3.4.2 launch 文件设置节点名称
3.4.3 编码设置节点名称
3.5 话题重名
3.5.1 ros2 run 设置话题名称
3.5.2 launch 文件设置话题名称
3.5.3 编码设置话题名称
3.6 时间相关 API
3.6.1 Rate
3.6.2 Time
3.6.3 Duration
3.6.4 Time 与 Duration 运算
3.7 通信机制工具
3.7.1 命令工具
3.7.2 rqt 工具箱
3.8 通信机制实操


3.8.1 话题通信案例分析
3.8.2 话题通信实现
3.8.3 服务通信案例分析
3.8.4 服务通信实现
3.8.5 动作通信案例分析
3.8.6 动作通信实现
3.8.7 参数服务案例分析
3.8.8 参数服务实现
3.9 本章小结
第 4 章 ROS2 工具之 launch 与 rosbag2
4.1 启动文件 launch 简介
4.1.1 launch 基本使用流程
4.2 launch 之 Python 实现
4.2.1 节点设置
4.2.2 执行指令
4.2.3 参数设置
4.2.4 文件包含
4.2.5 分组设置
4.2.6 添加事件
4.3 launch 之 xml、yaml 实现
4.3.1 节点设置
4.3.2 执行指令
4.3.3 参数设置
4.3.4 文件包含


4.3.5 分组设置
4.4 录制回放工具——rosbag2
4.4.1 ros2 bag 命令工具
4.4.2 rosbag2 编程(C++)
4.4.3 rosbag2 编程(Python)
4.5 本章小结
第 5 章 ROS2 工具之坐标变换
5.1 坐标变换简介
5.1.1 案例安装以及运行
5.2 坐标相关消息
5.3 坐标变换广播
5.3.1 坐标系广播案例以及分析
5.3.2 静态广播器(命令)
5.3.3 静态广播器(C++)
5.3.4 静态广播器(Python)
5.3.5 动态广播器(C++)
5.3.6 动态广播器(Python)
5.3.7 坐标点发布案例以及分析
5.3.8 坐标点发布(C++)
5.3.9 坐标点发布(Python)
5.4 坐标变换监听
5.4.1 坐标系变换案例以及分析
5.4.2 坐标系变换(C++)
5.4.3 坐标系变换(Python)


5.4.4 坐标点变换(C++)
5.4.5 坐标点变换(Python)
5.5 坐标变换工具
5.6 坐标变换实操
5.6.1 乌龟跟随案例以及分析
5.6.2 乌龟跟随实现(C++)
5.6.3 乌龟跟随实现(Python)
5.6.4 乌龟护航案例以及分析
5.6.5 乌龟护航实现(C++)
5.6.6 乌龟护航实现(Python)
5.7 本章小结
第 6 章 ROS2 工具之可视化
6.1 可视化简介
6.2 rviz2 基本使用
6.3 rviz2 集成 URDF 基本流程
6.3.1 案例以及案例分析
6.3.2 案例实现
6.4 URDF 使用语法
6.4.1 URDF 语法 01_robot
6.4.2 URDF 语法 02_link
6.4.3 URDF 语法 03_joint
6.4.4 URDF 练习
6.4.5 URDF 工具
6.5 URDF 优化_xacro


6.5.1 xacro_快速体验
6.5.2 xacro_使用语法
6.5.3 xacro_练习


1
课程简介
《ROS2 理论与实践》系列课程主要由基础篇、核心篇、应用篇、进阶篇以及项目库五部分组成。本阶段为《ROS2
理论与实践——核心篇》课程,核心篇课程设计以官方内容为标准,主要介绍 ROS2 中的通信机制与开发者工具,
其中前者是整个 ROS2 框架中的核心构成,而后者则为开发者能够高效的构建应用程序提供有力支持。本阶段课程
目的是帮助大家快速上手 ROS2,为后续进阶奠定基础。
1.课程内容
本阶段教程主要内容如下:
章节 学习内容 学习收获
第 1 章 ROS2 概述
与环境搭建
ROS2 相关概念以及如何使用
VScode 搭建集成开发环境。
能够了解 ROS2,了解工作中常用的模块有哪
些,并可以自行搭建对开发者友好的学习、
工作环境。
第 2 章 ROS2 通信
机制核心
ROS2 中频繁使用的通信机制
(话题、服务、动作、参数)
的应用场景以及实现。
该部分与工作内容高度契合,可以让开发者
根据不同场景、不同需求灵活实现机器人系
统中的数据交互。
第 3 章 ROS2 通信
机制补充
ROS2 中一些零散但比较实用
的知识点。 避免程序“陷阱”,完善通信机制的应用。
第 4 章 ROS2 工具
之 launch 与
rosbag2
launch 文件与 rosbag2 录制、
回放话题消息。
通过 launch 能够为大型项目构建启动文件;
通过 rosbag2 能够复用、生产数据,降低开
发成本,提高开发效率,缩短产品落地时间。
第 5 章 ROS2 工具
之坐标变换 tf 坐标变换。
通过坐标变换可以确定机器人不同部件或不
同机器人之间的位姿关系,无论是单机器人
还是多机器人组队都有着广泛应用。
第 6 章 ROS2 工具
之可视化
rviz2 三维可视化工具和
URDF 机器人建模。
可以创建机器人模型,并可以图形化显示
ROS2 系统中的抽象数据,让开发者以机器人
的视角看世界。
每章伊始,都会列出该章的一些代表性案例,大家也可以通过浏览案例来简单了解该章的对应内容。
2.课程特点
课程中知识点的学习整体是以案例为导向的,每一个知识点基本都会设计一个具体的案例,然后课程遵循理论结合实
践的基本思路来介绍相关内容。
 在理论部分会介绍该知识点的应用场景、概念以及作用;
 实践部分则会介绍案例的实现思路、流程以及具体代码实现。
3.答疑


2
1.学习这套课程需要哪些知识储备?
答:需要提前了解编程语言 C++和 Python,这两种编程语言是重点,除此之外,还会使用到其他知识点,比如:linux、
cmake、xml、yaml 等,这部分内容可以现学现用。或者也可以先学习《ROS2 理论与实践——基础篇》内容。
2.学习这套课程需要学习 ROS1 吗?
答:不需要。如果有 ROS1 基础那么更好,如果没有 ROS1 基础,也不必担心,《ROS2 理论与实践》设计的初衷
就是面向小白的零基础机器人教程。
3.这套课程采用的是 ROS2 的那个版本?运行在什么操作系统上?
答:课程采用的是 ROS2 的 humble 版本。运行在 Linux(Ubuntu 22.04)操作系统上。
4.这套课程需要使用硬件吗?
答:暂不需要。如果有,那么更好。
4.参考资料
ROS2 官网链接:https://www.ros.org/




3
第 1 章 ROS2 概述与环境搭建
ROS 是机器人操作系统(Robot Operating System)的英文缩写,是用于构建机器人应用程序的软件开发工具包。自
ROS 诞生以来,由于其集开源、免费、易用、低耦合、生态丰富......诸多优点于一身,迅速成为机器人行业内最受欢
迎的开发框架之一,在学术、民用、商业、军事、航空航天等领域有着广泛的应用,并且随着 ROS2 对 ROS1 的全
面迭代升级,也使得 ROS 日趋于完善,可预见的,未来很长一段时间,ROS 仍将是机器人开发的中坚力量,而对于
ROS 自身而言,ROS1 会慢慢退出,ROS2 则冉冉升起。
本章作为 ROS2 核心教程的开篇,以 ROS2 的综述性知识为主,会循序渐进的带领大家认识 ROS2、安装 ROS2 并
搭建其集成开发环境,为 ROS2 的全方位学习做好准备。
本章概览
章节 学习内容 学习收获
1.1 ROS2 简
介
ROS2 的理论知识,比如:概念、
发展历程、组成体系、在机器人领
域的应用优势等。
可以了解 ROS2 在机器人领域的地位以及定
位。
1.2 ROS2 安
装
ROS2 在 Ubuntu 操作系统下的安
装、测试与基本使用配置。 能够独立搭建 ROS2 的开发、运行环境。
1.3 ROS2 快
速体验
介绍如何分别使用 C++ 和
Python 实现第一个 ROS2 小程序。 能够掌握 ROS2 程序的编写、编译与执行流程。
1.4 ROS2 集
成开发环境
搭建
介绍如何使用 VSCode 搭建 ROS2
的集成开发环境。
能够独立完成 VSCode 安装并配置 ROS2 相关
插件,提高程序的开发效率。
1.5 ROS2 体
系框架
ROS2 的文件系统以及常用的功能
模块。
能够在宏观上建立对 ROS2 的体系结构的基本
认知,大致了解各个模块的应用场景,明确
开发过程中的重点工作内容。
1.6 本章小
结 知识点汇总。 知识点回顾。
案例演示
案例 1:ROS2 安装完毕后,运行其官方例程:小乌龟。


4
案例 2:自实现第一个 ROS2 小程序,在终端输出文本:hello world!。
案例 3:使用 VSCode 搭建 ROS2 集成开发环境,提高开发效率。


5
1.1 ROS2 简介
场景
机器人是一种高度复杂的系统性实现,机器人设计包含了机械结构设计、机械加
工、硬件设计、嵌入式软件设计、上层软件设计等诸多模块,是各种硬件与软件
的有机结合,甚至可以说机器人系统是当今工业体系的集大成者。机器人体系是
相当庞大的,其复杂度之高,以至于没有任何个人、组织甚至公司能够独立完成
系统性的机器人研发生产任务。
那么问题随之而来:既然机器人实现如此困难,那么我们应该如何开展相关工作
呢?
一种合适的策略是——合作。让机器人研发者专注于自己擅长的领域,其他模块
则直接复用相关领域更专业研发团队的实现,当然自身的研究也可以被他人继续
复用。这种基于“复用”的分工协作,遵循了不重复发明轮子的原则,显然是可以
大大提高机器人的研发效率的,尤其是随着机器人硬件越来越丰富,软件库越来
越庞大,这种复用性和模块化开发需求也愈发强烈。
在此大背景下,便诞生了 ROS。ROS 是一套机器人通用软件框架,可以提升功能
模块的复用性,并且随着 ROS2 的推出,ROS 日臻完善,是机器人软件开发的不
二之选。
概念
ROS(Robot Operating System)是用于构建机器人应用程序的软件开发工具包。ROS 是开源的,它由一组软件
库和若干工具组成。
在机器人领域,ROS 是一个标准软件平台,这个平台为开发者提供了构建机器人应用程序所需的各个功能模块,并
且开发者能够以“可插拔”的方式组织各个功能模块,无论开发者的程序是用于课堂实验、科学研究、原型设计或是最
终产品,ROS 都提供了一站式的技术支持。
另外需要注意的是,ROS 虽然字面意思是机器人操作系统,但是它并非经典意义上的操作系统,更准确的讲 ROS 是
一个 SDK(Software Development Kit)也即软件开发工具包。
作用
秉着“不要重复发明轮子”的原则,通过 ROS 可以复用已有功能并方便快捷的拓展新功能。
1.1.1 ROS2 发展历程
1.起源


6
2007 年,一家名为柳树车库(Willow Garage)的机器人公司发布了 ROS,ROS 集开源、免费、
高复用、低耦合、工具丰富等等诸多优势于一身,一经推出便迅速吸引了大量的开发者、科研人员、
硬件供应商的加入,形成了稳定且多样的机器人生态,水到渠成的 ROS 也成为了机器人领域的主
流软件框架并流行至今。
但是自 ROS 诞生的十几年来,不管是机器人相关软件、硬件还是 ROS 社区都发生了天翻地覆的变
化,加之 ROS1 存在一些设计上的先天性缺陷,各种内外因素叠加下,导致 ROS1 在许多应用场
景下都已经显得力不从心了。此背景下,官方于 2017 正式推出了新一代机器人操作系统——ROS2,
ROS2 基于全新的设计框架,保留了 ROS1 的优点并改进其缺陷,ROS2 的目标是适应新时代的新
需求。
2.发行版本
ROS 发行版是一组版本化的 ROS 功能包,它类似于 Linux 发行版(例如 Ubuntu)。ROS 发行版
的目的是让开发人员可以在一个相对稳定的代码库上工作,直到新的发行版推出。
以下列表为 ROS2 各不同发布版本的简单说明。
发行版 发布日期 标识 停止维护日期
Iron Irwini 2023 年 5 月 23 日 待定 2024 年 11 月
Humble Hawksbill 2022 年 5 月 23 日 2027 年 5 月
Galactic Geochelone 2021 年 5 月 23 日 2022 年 11 月


7
发行版 发布日期 标识 停止维护日期
Foxy Fitzroy 2020 年 6 月 5 日 2023 年 5 月
Eloquent Elusor 2019 年 11 月 22 日 2020 年 11 月
Dashing Diademata 2019 年 5 月 31 日 2021 年 5 月
Crystal Clemmys 2018 年 12 月 14 日 2019 年 12 月


8
发行版 发布日期 标识 停止维护日期
Bouncy Bolson 2018 年 7 月 2 日 2019 年 7 月
Ardent Apalone 2017 年 12 月 8 日 2018 年 12 月
beta3 2017 年 9 月 13 日 2017 年 12 月
beta2 2017 年 7 月 5 日 2017 年 9 月
beta1 2016 年 12 月 19 日 2017 年 7 月
alpha1 - alpha8 2015 年 8 月 31 日 2016 年 12 月
ROS2 版本发布特点:
 发布版本与 Ubuntu 版本对应,生命周期也有 Ubuntu 保持一致,正常情况下偶数年份发布
长支持版(5 年),奇数年份发布短支持版(2 年);
 版本名称由形容词+名词的格式组成,这一点与 Ubuntu 版本名称规则一致;
 正常情况下,每年的 5 月 23 日,世界海龟日发布新版本。
需要另外说明的是:
官方于 2020 年发布了 ROS1 的最终版本,并将于 2025 年终止 ROS1 的维护。而早在 2017 年就
已经推出了 ROS2 的第一个正式版本,并且随着 ROS2 的不断完善,于 2022 年又推出 ROS2 的
第一个 5 年长支持版。对于 ROS 而言,这是一个里程碑式的事件,这意味着自此开始,ROS2 将
全面取代 ROS1。


9
1.1.2 ROS2 组成体系
整个 ROS 生态由通信(Plumbing)、工具(Tools)、功能(Capabilities)与社区(Community)
四大部分组成。
通信(Plumbing)
通信是整个 ROS 系统的核心实现,是 ROS 内置的一个消息传递系统,通常称之为 middleware(中
间件)或 Plumbing(管道)。
在构建新的应用程序或使用与硬件交互的软件时,如何实现通信是首当其冲的问题,为此 ROS 提
供了专门的消息传递系统,它可以管理不同节点之间的通信细节,提高开发者的工作效率。这套消
息传递系统使用了“面向接口”的编程思想,可以通过清晰规范的接口,将不同模块分离,从而也将
故障隔离。使得 ROS 系统更易于维护、扩展性更强且保证了程序的高复用性。
接口规范可以由开发者自行定义。同时为了方便使用,在 ROS 中也提供了许多标准的接口,这些
标准接口有着广泛应用,比如:将雷达或摄像头数据传输到可视化的用户界面或是传输到定位算法
模块,都会使用到标准接口。
工具(Tools)
构建机器人应用程序极具挑战性。开发者除了会遇到一些传统的软件开发问题之外,还需要通过传
感器或执行器与物理世界进行异步交互。显而易见的,良好的开发工具可以提高应用程序的开发效
率,在 ROS 中就内置了 launch、调试、可视化、绘图、录制回放等一系列工具。这些工具不光可
以提高开发效率,还可以在发布产品时直接包含在产品之中。
功能(Capabilities)
ROS 生态系统是机器人软件的聚宝盆。无论开发者需要用于 GPS 的设备驱动程序、用于四足仿生
机器人的步行和平衡控制器,还是用于移动机器人的地图系统,ROS 都能满足你的需求。从驱动
程序到算法,再到用户界面,ROS 都提供了相关实现,开发者只需专注于自身应用程序即可。
ROS 的目标是提供一站式的技术支持,降低构建机器人应用程序的门槛。ROS 希望任何开发者都
可以将自己的“创意”变为现实,而无需了解底层软件和硬件的所有内容。
社区(Community)


10
ROS 社区规模庞大、多样且全球化,从学生和业余爱好者到跨国公司和政府机构,各行各业的人
和组织都在推动着 ROS 项目的发展。
该项目的社区中心和中立管家是 Open Robotics,它托管共享在线服务(例如 ROS 官网:
https://www.ros.org/),创建和管理分发版本(包括您安装的二进制包),并开发和维护大部分
ROS 核心软件。 Open Robotics 还提供与 ROS 相关的工程服务。


11
1.1.3 ROS2 优势
1.ROS 与其他机器人软件框架比较
ROS 是构建机器人的最快捷方式!
1.1 开源
ROS 一直是开源的,并且将永远是开源的,以确保全世界的爱好者、开发人员可以自由、不受限
制地访问高质量、一流、功能齐全的机器人 SDK。另外官方也在其他开源项目之上构建 ROS,ROS
会尽可能的利用并遵循开放标准(例如 OMG 的 DDS)。
1.2 免费
官方鼓励用户对 ROS 做出开源贡献,也欢迎提出宝贵意见,但不干涉开发者将 ROS 集成进非开源
软件,不反对将 ROS 集成进专有产品。
1.3 多平台支持
ROS2 支持 Linux、Windows 和 macOS 以及各种嵌入式平台(通过 micro-ROS)并且不同平台都
已经通过了官方测试,这意味着通过 ROS2 可以实现开发、部署后端管理系统和用户界面的无缝衔
接。分层支持模型还允许将 ROS2 移植到诸如实时和嵌入式操作系统等新平台上,以便在获得关注
和投资时将 ROS2 引入和推广到这些新平台中。
1.4 应用领域广泛
ROS 可以在各种机器人应用中使用,从室内到室外,从家用到汽车,从水下到太空,从消费市场
到工业领域,ROS 都可以独当一面。
1.5 全球化社区
十多年来,ROS 项目通过培育由数百万开发人员和用户组成的全球化社区,为机器人技术做出贡
献和改进,从而产生了一个庞大的机器人软件生态系统。 ROS 由该社区开发并为该社区服务,该
社区将成为其未来的管理者。
1.6 可缩短产品上市时间
ROS 提供了开发机器人应用程序所需的工具、库和功能,使开发者可以将更多的时间花费在与自
身业务相关的工作上。由于它还是开源的,所以开发者可以决定何时何处使用 ROS,甚至还可以
根据自身需求修改 ROS。另外 ROS 是友好的,不具排他性,开发者可以在 ROS 和其他机器人软
件框架之间自由选择,或者也可以将 ROS 与其他软件框架集成,以取长补短。
1.7 广泛的行业支持
业界对 ROS 的支持非常强大。除了在 ROS 上开发产品外,来自世界各地的大大小小的公司都在投
入资源为 ROS 做出开源贡献。


12
1.8 业界肯定
整个机器人行业都依赖于 ROS。ROS 是教授机器人技术的标准,是大多数机器人研究的基础,从
单个学生项目到多机构合作再到大型 竞赛,ROS 都占据着主导地位。世界各地不计其数的机
器人内部都运行着 ROS,仅在自主移动机器人 (AMR) 中,ROS 就帮助创造了数十亿美元的价值。
2.ROS2 较之于 ROS1 的优势
ROS2 是全新一代机器人操作系统,不只是功能增强的 ROS1。
2.1 去中心化
在 ROS1 中使用 master 节点管理调度 ROS 系统,这存在极大的安全隐患,一旦 master 节点异常
退出,那么会导致整个系统的崩溃。在 ROS2 中采用了去中心化,各个节点之间无需通过 master
关联,各个节点都是等态的,可以相互发现彼此。
2.2 全新通信底层实现
秉着不重复发明轮子的原则,ROS2 不再自实现通信底层,而是直接更换为 DDS 通信,这使得 ROS2
较之于 ROS1 无论是通信的实行性、可靠性还是连续性都有大幅度提升。
2.3 应用场景更为广泛
ROS1 在设计之初有着天生的硬件优势以及局限性:
 单机;
 工作站级的计算资源;
 无实时性要求(有此类需求也可以以特殊方式满足);
 出色的网络连接(有线或近距离高带宽无线);
 主要用于学术界;
 灵活有余而约束不足。
这导致了它的一些先天性缺陷,不能适应新时代的需求,比如:
 对多机器人编队支持欠佳;
 小型嵌入式平台不能很好的支持 ROS;
 实时性差;
 ROS 之间的数据传输受网络质量影响严重;
 产品不易落地。
随着 ROS2 的推出,上述场景的缺陷都得到很大程度的修复。
2.4 大量采用新技术、新的设计理念
随着 ROS 十数年的发展,大量的新技术也产生、改进、成熟并被广泛采用,ROS 也开始引入并应
用一些新技术,比如:


13
DDS( Data Distribution Service——数据分发服务);
Zeroconf;
ZeroMQ;
Redis;
WebSockets。
这些新技术为 ROS 带来了更多的便利,比如:更少的维护成本,却有着更多的功能拓展,并且随
着第三方库的升级而持续受益。
此外,ROS2 还重构了 API 系统,改进了 ROS1 的 API 在设计上的不足。


14
1.2 ROS2 安装
本节主要介绍如何在 Ubuntu 操作系统上安装 ROS2,所以在安装之前请先准备好与 ROS2 版本相
匹配的 Ubuntu 操作系统。
1.2.1 安装 ROS2
整体而言,ROS2 的安装步骤不算复杂,大致步骤如下:
1. 准备 1:设置语言环境;
2. 准备 2:启动 Ubuntu universe 存储库;
3. 设置软件源;
4. 安装 ROS2;
5. 配置环境。
请注意:虽然安装比较简单,但是安装过程比较耗时,需要耐心等待。
1.准备 1:设置语言环境
请先检查本地语言环境是否支持 UTF-8 编码,可调用如下指令检查并设置 UTF-8 编码:
locale # 检查是否支持 UTF-8
sudo apt update && sudo apt install locales
sudo locale-gen en_US en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
export LANG=en_US.UTF-8
locale # 验证设置是否成果
注意:语言环境可以不同,但必须支持 UTF-8 编码。
2.准备 2:启动 Ubuntu universe 存储库
常用的启动 Ubuntu universe 存储库方式有两种:图形化操作与命令行操作。
方式 1:图形化操作


15
请打开软件与更新(Software & Updates)窗口,确保启动了 universe 存储库,以保证可以下载”社区
维护的免费和开源软件“,操作示例如下:
方式 2:命令行操作
首先,通过如下命令检查是否已经启动了 Ubuntu universe 存储库:
apt-cache policy | grep universe
500 http://us.archive.ubuntu.com/ubuntu jammy/universe amd64 Packages
release v=22.04,o=Ubuntu,a=jammy,n=jammy,l=Ubuntu,c=universe,b=amd64
如果没有如上所示的输出,那么请调用如下命令启动 Ubuntu universe 存储库:
sudo apt install software-properties-common
sudo add-apt-repository universe
3.设置软件源
先将 ROS 2 apt 存储库添加到系统,用 apt 授权我们的 GPG 密钥:
sudo apt update && sudo apt install curl gnupg lsb-release
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o
/usr/share/keyrings/ros-archive-keyring.gpg
提示:如果抛出连接 raw.githubusercontent.com 失败的异常信息,解决方式请
参考本节最后部分补充 2 内容。
然后将存储库添加到源列表:


16
echo "deb [arch=$(dpkg --print-architecture)
signed-by=/usr/share/keyrings/ros-archive-keyring.gpg]
http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME)
main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
4.安装 ROS2
首先更新 apt 存储库缓存:
sudo apt update
然后升级已安装的软件(ROS2 软件包建立在经常更新的 Ubuntu 系统上,在安装新软件包之前请确
保您的系统是最新的):
sudo apt upgrade
安装桌面版 ROS2(建议),包含:ROS、RViz、示例与教程,安装命令如下:
sudo apt install ros-humble-desktop
或者,也可以安装基础版 ROS2,包含:通信库、消息包、命令行工具,但是没有 GUI 工具,安
装命令如下:
sudo apt install ros-humble-ros-base
5.配置环境
终端下,执行 ROS2 程序时,需要调用如下命令配置环境:
source /opt/ros/humble/setup.bash
每次新开终端时,都得执行上述命令,或者也可以执行如下命令,将配置环境指令写
入 ”~/.bashrc“ 文件,那么每次新启动终端时,不需要在手动配置环境:
echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
到目前为止,ROS2 就已经安装且配置完毕了。
补充 1:关于卸载(谨慎操作)
ROS2 安装完毕之后,如果想卸载 ROS2,可以执行如下命令:
sudo apt remove ~nros-humble-* && sudo apt autoremove


17
还可以再删除 ROS2 对应的存储库:
sudo rm /etc/apt/sources.list.d/ros2.list
sudo apt update
sudo apt autoremove
# Consider upgrading for packages previously shadowed.
sudo apt upgrade
补充 2:关于 raw.githubusercontent.com 连接失败的处理
安装 ROS2 过程中,执行到步骤 3 也即设置软件源时,可能会抛出异常。
异常提示:curl: (7) Failed to connect to raw.githubusercontent.com port 443: 拒绝连接。
异常原因:DNS 被污染。
解决思路:查询错误提示中域名的 IP 地址,然后修改 /etc/hosts 文件,添加域名与 IP 映射。
具体实现:
1.访问 https://www.ipaddress.com/ 并输入域名 raw.githubusercontent.com,查询 ip 地址。


18
查询到的 ip 地址可能有多个,记录任意一个地址即可。
2.修改/etc/hosts 文件:
sudo gedit /etc/hosts
添加 ip 和域名映射到 hosts 文件,保存并退出。
操作完毕后,终端再次运行安装指令即可正常执行


19
1.2.2 测试 ROS2
在 ROS2 中已经内置了一些案例,安装完毕之后,就可以运行这些案例,以测试 ROS2 的安装与
配置是否正常,在此,我们选用 ROS2 内置的小乌龟案例,具体操作如下。
1.打开两个终端(可以使用快捷键 Ctrl + Alt + T);
2.终端 1 中输入指令:ros2 run turtlesim turtlesim_node,执行完毕,会启动一个绘有小乌龟的
窗口;
3.终端 2 中输入指令:ros2 run turtlesim turtle_teleop_key,执行完毕,可以在此终端中通过
键盘控制乌龟运动。
运行结果示例如下:
注意:在使用键盘控制乌龟运动时,需要保证光标聚焦在终端 2 中,否则乌龟无响应。
1.2.3 安装 colcon 构建工具
colcon 是一个命令行工具,用于改进编译,测试和使用多个软件包的工作流程。它实现过程自动化,
处理需求并设置环境以便于使用软件包。ROS2 中便是使用 colcon 作为包构建工具的,但是 ROS2
中没有默认安装 colcon,需要自行安装,安装命令如下:
sudo apt install python3-colcon-common-extensions
安装完 colcon 之后,就可以在 ROS2 中编写应用程序了,下一节我们将介绍 ROS2 版本的
HelloWorld 实现。


20
1.3 ROS2 快速体验
ROS2 中涉及的编程语言以 C++和 Python 为主,ROS2 中的大多数功能两者都可以实现,在本系
列教程中,如无特殊情况,每一个案例也都会分别使用 C++和 Python 两种方案演示。本节我们将
介绍一个最基本的案例——ROS2 版本的 HelloWorld,通过学习本节内容,你可以了解 ROS2 程序
的编写、编译与执行流程。
1.3.1 案例简介
1.需求
编写 ROS2 程序,要求程序运行时,可以在终端输出文本"Helo World"。
2.准备
无论是使用 C++还是 Python 编写 ROS2 程序,都需要依赖于工作空间,在此,我们先实现工作空
间的创建与编译,打开终端,输入如下指令:
mkdir -p ws00_helloworld/src #创建工作空间以及子级目录 src,工作空间名称可以自定义
cd ws00_helloworld #进入工作空间
colcon build #编译
上述指令执行完毕,将创建 ws00_helloworld 目录,且该目录下包含 build、install、log、src 共四
个子级目录。
3.流程简介
工作空间创建完毕后,我么可以在工作空间下的 src 目录中编写 C++或 Python 程序,且两种语言
的实现流程大致一致,主要包含如下步骤:
 创建功能包;
 编辑源文件;
 编辑配置文件;
 编译;
 执行。
下面两节我们会介绍具体的实现细节。


21
1.3.2 HelloWorld(C++)
1.创建功能包
终端下,进入 ws00_helloworld/src 目录,使用如下指令创建一个 C++功能包:
ros2 pkg create pkg01_helloworld_cpp --build-type ament_cmake --dependencies rclcpp
--node-name helloworld
执行完毕,在 src 目录下将生成一个名为 pkg01_helloworld_cpp 的目录,且目录中已经默认生成了
一些子级文件与文件夹。
2.编辑源文件
进入 pkg01_helloworld_cpp/src 目录,该目录下有一 helloworld.cpp 文件,修改文件内容如下:
#include "rclcpp/rclcpp.hpp"
int main(int argc, char ** argv){
// 初始化 ROS2
rclcpp::init(argc,argv);
// 创建节点
auto node = rclcpp::Node::make_shared("helloworld_node");
// 输出文本
RCLCPP_INFO(node->get_logger(),"hello world!");
// 释放资源
rclcpp::shutdown();
return 0;
}
3.编辑配置文件
在步骤 1 创建功能包时所使用的指令已经默认生成且配置了配置文件,不过实际应用中经常需要自
己编辑配置文件,所以在此对相关内容做简单介绍,所使用的配置文件主要有两个,分别是功能包
下的 package.xml 与 CMakeLists.txt。


22
1.package.xml
文件内容如下:
<?xml version="1.0"?><?xml-model
href="http://download.ros.org/schema/package_format3.xsd"
schematypens="http://www.w3.org/2001/XMLSchema"?><package format="3">
<name>pkg01_helloworld_cpp</name>
<version>0.0.0</version>
<description>TODO: Package description</description>
<maintainer email="ros2@todo.todo">ros2</maintainer>
<license>TODO: License declaration</license>
<buildtool_depend>ament_cmake</buildtool_depend>
<!-- 所需要依赖 -->
<depend>rclcpp</depend>
<test_depend>ament_lint_auto</test_depend>
<test_depend>ament_lint_common</test_depend>
<export>
<build_type>ament_cmake</build_type>
</export></package>
注释部分以后需要根据实际的包依赖进行添加或修改。
2.CMakeLists.txt
文件内容如下:
cmake_minimum_required(VERSION 3.8)


23
project(pkg01_helloworld_cpp)
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
add_compile_options(-Wall -Wextra -Wpedantic)
endif()
# find dependencies
find_package(ament_cmake REQUIRED)
# 引入外部依赖包
find_package(rclcpp REQUIRED)
# 映射源文件与可执行文件
add_executable(helloworld src/helloworld.cpp)
# 设置目标依赖库
ament_target_dependencies(
helloworld
"rclcpp"
)
# 定义安装规则
install(TARGETS helloworld
DESTINATION lib/${PROJECT_NAME})
if(BUILD_TESTING)
find_package(ament_lint_auto REQUIRED)


24
# the following line skips the linter which checks for copyrights
# comment the line when a copyright and license is added to all source files
set(ament_cmake_copyright_FOUND TRUE)
# the following line skips cpplint (only works in a git repo)
# comment the line when this package is in a git repo and when
# a copyright and license is added to all source files
set(ament_cmake_cpplint_FOUND TRUE)
ament_lint_auto_find_test_dependencies()
endif()
ament_package()
中文注释部分以后可能需要根据实际情况修改。
4.编译
终端下进入到工作空间,执行如下指令:
colcon build
5.执行
终端下进入到工作空间,执行如下指令:
. install/setup.bash
ros2 run pkg01_helloworld_cpp helloworld
程序执行,在终端下将输出文本:"hello world!"。


25
1.3.3 HelloWorld(Python)
1.创建功能包
终端下,进入 ws00_helloworld/src 目录,使用如下指令创建一个 python 功能包:
ros2 pkg create pkg02_helloworld_py --build-type ament_python --dependencies rclpy
--node-name helloworld
执行完毕,在 src 目录下将生成一个名为 pkg02_helloworld_py 的目录,且目录中已经默认生成了
一些子级文件与文件夹。
2.编辑源文件
进入 pkg02_helloworld_py/pkg02_helloworld_py 目录,该目录下有一 helloworld.py 文件,修改文
件内容如下:
import rclpy
def main():
# 初始化 ROS2
rclpy.init()
# 创建节点
node = rclpy.create_node("helloworld_py_node")
# 输出文本
node.get_logger().info("hello world!")
# 释放资源
rclpy.shutdown()
if __name__ == '__main__':
main()
3.编辑配置文件


26
与 C++类似的,在步骤 1 创建功能包时所使用的指令也已经默认生成且配置了配置文件,不过实际
应用中经常需要自己编辑配置文件,所以在此对相关内容做简单介绍,所使用的配置文件主要有两
个,分别是功能包下的 package.xml 与 setup.py。
1.package.xml
文件内容如下:
<?xml version="1.0"?><?xml-model
href="http://download.ros.org/schema/package_format3.xsd"
schematypens="http://www.w3.org/2001/XMLSchema"?><package format="3">
<name>pkg02_helloworld_py</name>
<version>0.0.0</version>
<description>TODO: Package description</description>
<maintainer email="ros2@todo.todo">ros2</maintainer>
<license>TODO: License declaration</license>
<!-- 所需要依赖 -->
<depend>rclpy</depend>
<test_depend>ament_copyright</test_depend>
<test_depend>ament_flake8</test_depend>
<test_depend>ament_pep257</test_depend>
<test_depend>python3-pytest</test_depend>
<export>
<build_type>ament_python</build_type>
</export></package>
注释部分以后需要根据实际的包依赖进行添加或修改。


27
2.setup.py
文件内容如下:
from setuptools import setup
package_name = 'pkg02_helloworld_py'
setup(
name=package_name,
version='0.0.0',
packages=[package_name],
data_files=[
('share/ament_index/resource_index/packages',
['resource/' + package_name]),
('share/' + package_name, ['package.xml']),
],
install_requires=['setuptools'],
zip_safe=True,
maintainer='ros2',
maintainer_email='ros2@todo.todo',
description='TODO: Package description',
license='TODO: License declaration',
tests_require=['pytest'],
entry_points={
'console_scripts': [


28
# 映射源文件与可执行文件
'helloworld = pkg02_helloworld_py.helloworld:main'
],
},
)
注释部分以后可能需要根据实际情况修改。
4.编译
终端下进入到工作空间,执行如下指令:
colcon build
5.执行
终端下进入到工作空间,执行如下指令:
. install/setup.bash
ros2 run pkg02_helloworld_py helloworld
程序执行,在终端下将输出文本:"hello world!"。
1.3.4 运行优化
每次终端中执行工作空间下的节点时,都需要调用. install/setup.bash 指令,使用不便,优化策
略是,可以将该指令的调用添加进~/setup.bash,操作格式如下:
echo "source /{工作空间路径}/install/setup.bash" >> ~/.bashrc
示例:
echo "source /home/ros2/ws00_helloworld/install/setup.bash" >> ~/.bashrc
以后再启动终端时,无需手动再手动刷新环境变量,使用更方便。


29
1.4 ROS2 集成开发环境搭建
和大多数开发环境一样,理论上,在 ROS2 中,只需要记事本就可以编写基本的 ROS2 程序,但
是工欲善其事必先利其器,为了提高开发效率,可以先安装集成开发工具和使用方便的工具:IDE、
终端、git。
1.4.1 安装 VSCode
VSCode 全称 Visual Studio Code,是微软推出的一款轻量级代码编辑器,免费、开源而且功能强
大。它支持几乎所有主流的程序语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片
段、代码对比 Diff、GIT 等特性,支持插件扩展,并针对网页开发和云端应用开发做了优化。软件
跨平台支持 Win、Mac 以及 Linux。
1.下载
vscode 下载:https://code.visualstudio.com/Download。
历史版本下载链接:https://code.visualstudio.com/updates。
2.vscode 安装与卸载
2.1 安装
方式 1:双击安装即可(或右击选择安装);
方式 2:sudo dpkg -i xxxx.deb。
2.2 卸载
sudo dpkg --purge code
3.VSCode 启动
VSCode 启动也比较简单,可以直接在 Show Applications(显示应用程序) 中搜索 VSCode 直接启
动(也可以将其添加到收藏夹)。
或者,也可以在终端下进入需要被打开的目录(比如:前面创建的 ROS2 工作空间 ws00_helloworld),
然后输入命令:code .。
4.VSCode 插件
VSCode 支持插件扩展,依赖于 VSCode 丰富多样的插件,可以大大提高程序开发效率,为了方便
ROS2 程序开发,我们也需要安装一些插件。


30
首先点击侧边栏的 Extensions(插件)选项或者使用快捷键 Ctrl+Shift+X 打开插件窗口,本课程建议
安装的插件如下:
当然,上述只是部分推荐插件,大家可以根据自身需求安装其他扩展。
5.VSCode 配置
在 VSCode 中,cpp 文件中的#include "rclcpp/rclcpp.hpp"包含语句会抛出异常,这是因为没有
设置 VSCode 配置文件中 includepath 属性,可以按照如下步骤解决此问题:


31
1. 将鼠标移到错误提示语句,此时会出现弹窗;
2. 点击弹窗中的快速修复,会有新的弹窗,再点击编辑"includePath"设置;
3. 在 新 页 面 中 , 包 含 路 径 属 性 对 应 的 文 本 域 中 , 换 行 输 入 被 包 含 的 路 径
/opt/ros/humble/include/**。
至此,问题修复。
VSCode 安装并配置完毕后,大家就可以在其中编写 ROS2 程序了。当然为了提高编码效率,我们
会经常性的使用到一些快捷键,VSCode 的快捷键可以在菜单栏的“帮助”中查看。
1.4.2 安装终端
在 ROS2 中,需要频繁的使用到终端,且可能需要同时开启多个窗口,推荐一款较为好用的终端:
Terminator。效果如下:


32
1.安装
sudo apt install terminator
2.启动
可以直接在 Show Applications(显示应用程序) 中搜索 terminator 直接启动(也可以将其添加到收藏
夹);或者,也可以直接使用快捷键 Ctrl+Alt+T 启动。
3.Terminator 常用快捷键
第一部份:关于在同一个标签内的操作
Alt+Up //移动到上面的终端
Alt+Down //移动到下面的终端
Alt+Left //移动到左边的终端
Alt+Right //移动到右边的终端
Ctrl+Shift+O //水平分割终端
Ctrl+Shift+E //垂直分割终端
Ctrl+Shift+Right //在垂直分割的终端中将分割条向右移动
Ctrl+Shift+Left //在垂直分割的终端中将分割条向左移动
Ctrl+Shift+Up //在水平分割的终端中将分割条向上移动
Ctrl+Shift+Down //在水平分割的终端中将分割条向下移动
Ctrl+Shift+S //隐藏/显示滚动条
Ctrl+Shift+F //搜索
Ctrl+Shift+C //复制选中的内容到剪贴板
Ctrl+Shift+V //粘贴剪贴板的内容到此处
Ctrl+Shift+W //关闭当前终端
Ctrl+Shift+Q //退出当前窗口,当前窗口的所有终端都将被关闭
Ctrl+Shift+X //最大化显示当前终端


33
Ctrl+Shift+Z //最大化显示当前终端并使字体放大
Ctrl+Shift+N or Ctrl+Tab //移动到下一个终端
Ctrl+Shift+P or Ctrl+Shift+Tab //Crtl+Shift+Tab 移动到之前的一个终端
第二部份:有关各个标签之间的操作
F11 //全屏开关
Ctrl+Shift+T //打开一个新的标签
Ctrl+PageDown //移动到下一个标签
Ctrl+PageUp //移动到上一个标签
Ctrl+Shift+PageDown //将当前标签与其后一个标签交换位置
Ctrl+Shift+PageUp //将当前标签与其前一个标签交换位置
Ctrl+Plus (+) //增大字体
Ctrl+Minus (-) //减小字体
Ctrl+Zero (0) //恢复字体到原始大小
Ctrl+Shift+R //重置终端状态
Ctrl+Shift+G //重置终端状态并 clear 屏幕
Super+g //绑定所有的终端,以便向一个输入能够输入到所有的终端
Super+Shift+G //解除绑定
Super+t //绑定当前标签的所有终端,向一个终端输入的内容会自动输入到其他
终端
Super+Shift+T //解除绑定
Ctrl+Shift+I //打开一个窗口,新窗口与原来的窗口使用同一个进程
Super+i //打开一个新窗口,新窗口与原来的窗口使用不同的进程
1.4.3 安装 git
Git 是一个免费和开源的分布式版本控制系统,旨在高速高效的处理从小型到大型项目的所有内容。
在 Ubuntu 下可以调用如下命令安装 git:
sudo apt install git
在本教程中会经常使用 git clone 仓库地址的方式来将 Git 仓库拷贝到本地。
关于 git 工具使用可以在终端下输入:git --help 查看帮助文档。关于 git 的其他详细信息请参考:
https://git-scm.com/


34
1.5 ROS2 体系框架
在 1.1.2 ROS2 组成体系一节中,我们已经简单了解了 ROS2 的体系框架,并且随着前面介绍了
ROS2 功能包的编写、编译、执行流程,也对 ROS2 应用程序的构建有了基本的认识。本节会进一
步从微观和宏观两个维度来介绍 ROS2 的不同部分,以帮助大家了解 ROS2 的学习、工作内容以
及以后可选择的发展方向。
微观上会介绍 ROS2 的文件系统、ROS2 的核心模块(通信与工具),这些都是官方提供的标准内
容。宏观上会介绍关于 ROS2 的技术支持、ROS2 的应用方向,这部分则是得益于 ROS2 的强大
社区。
1.5.1 ROS2 文件系统
立足系统架构,如下图所示,ROS2 可以划分为三层:
 操作系统层(OS Layer)
如前所述,ROS 虽然称之为机器人操作系统,但实质只是构建机器人应用程序的软件开发工具包,
ROS 必须依赖于传统意义的操作系统,目前 ROS2 可以运行在 Linux、Windows、Mac 或 RTOS
上。
 中间层(Middleware Layer)
主要由数据分发服务 DDS 与 ROS2 封装的关于机器人开发的中间件组成。DDS 是一种去中心化的
数据通讯方式,ROS2 还引入了服务质量管理 (Quality of Service)机制,借助该机制可以保证
在某些较差网络环境下也可以具备良好的通讯效果。ROS2 中间件则主要由客户端库、DDS 抽象层
与进程内通讯 API 构成。
 应用层(Application Layer)
是指开发者构建的应用程序,在应用程序中是以功能包为核心的,在功能包中可以包含源码、数据
定义、接口等内容。
对于一般开发者而言,工作内容主要集中在应用层,开发者一般通过实现具有某一特定功能的功能
包来构建机器人应用程序。对应的我们所介绍的 ROS2 文件系统主要是指在硬盘上以功能包为核心
的目录与文件的组织形式。


35
1.概览
功能包是 ROS2 应用程序的核心,但是功能包不能直接构建,必须依赖于工作空间,一个 ROS2
工作空间的目录结构如下:
WorkSpace --- 自定义的工作空间。
|--- build:存储中间文件的目录,该目录下会为每一个功能包创建一个单独子目录。
|--- install:安装目录,该目录下会为每一个功能包创建一个单独子目录。
|--- log:日志目录,用于存储日志文件。
|--- src:用于存储功能包源码的目录。
|-- C++功能包
|-- package.xml:包信息,比如:包名、版本、作者、依赖项。
|-- CMakeLists.txt:配置编译规则,比如源文件、依赖项、目标文件。
|-- src:C++源文件目录。
|-- include:头文件目录。
|-- msg:消息接口文件目录。
|-- srv:服务接口文件目录。
|-- action:动作接口文件目录。
|-- Python 功能包
|-- package.xml:包信息,比如:包名、版本、作者、依赖项。
|-- setup.py:与 C++功能包的 CMakeLists.txt 类似。
|-- setup.cfg:功能包基本配置文件。
|-- resource:资源目录。
|-- test:存储测试相关文件。
|-- 功能包同名目录:Python 源文件目录。
另外,无论是 Python 功能包还是 C++功能包,都可以自定义一些配置文件相关的目录。


36
|-- C++或 Python 功能包
|-- launch:存储 launch 文件。
|-- rviz:存储 rviz2 配置相关文件。
|-- urdf:存储机器人建模文件。
|-- params:存储参数文件。
|-- world:存储仿真环境相关文件。
|-- map:存储导航所需地图文件。
|-- ......
上述这些目录也可以定义为其他名称,或者根据需要创建其他一些目录。
2.源文件说明
在 1.3 ROS2 快速体验中,实现第一个 ROS2 程序时,都需要创建节点,无论是 C++实现还是 Python
实现,都是直接实例化的 Node 对象。
C++实例化 Node 示例如下:
#include "rclcpp/rclcpp.hpp"
int main(int argc, char ** argv){
rclcpp::init(argc,argv);
auto node = rclcpp::Node::make_shared("helloworld_node");
RCLCPP_INFO(node->get_logger(),"hello world!");
rclcpp::shutdown();
return 0;
}
Python 实例化 Node 示例如下:
import rclpy
def main():
rclpy.init()


37
node = rclpy.create_node("helloworld_py_node")
node.get_logger().info("hello world!")
rclpy.shutdown()
if __name__ == '__main__':
main()
但是在 ROS2 中,上述编码风格是不被推荐的,更推荐以继承 Node 的方式来创建节点对象。
C++继承 Node 实现示例如下:
#include "rclcpp/rclcpp.hpp"
class MyNode: public rclcpp::Node{public:
MyNode():Node("node_name"){
RCLCPP_INFO(this->get_logger(),"hello world!");
}
};
int main(int argc, char *argv[]){
rclcpp::init(argc,argv);
auto node = std::make_shared<MyNode>();
rclcpp::shutdown();
return 0;
}
Python 继承 Node 实现示例如下:
import rclpyfrom rclpy.node import Node
class MyNode(Node):
def __init__(self):
super().__init__("node_name_py")


38
self.get_logger().info("hello world!")def main():
rclpy.init()
node = MyNode()
rclpy.shutdown()
之所以继承比直接实例化 Node 更被推荐,是因为继承方式可以在一个进程内组织多个节点,这对
于提高节点间的通信效率是很有帮助的,但是直接实例化则与该功能不兼容。
3.配置文件说明
在 ROS2 功能包中,经常需要开发者编辑一些配置文件以设置功能包的构建信息,功能包类型不同,
所需修改的配置文件也有所不同。C++功能包的构建信息主要包含在 package.xml 与
CMakeLists.txt 中,Python 功能包的构建信息则主要包含在 package.xml 和 setup.py 中,接下来
我们就简单了解一下这些配置文件。
1.package.xml
不管是何种类型的功能包,package.xml 的格式都是类似的,在该文件中包含了包名、版本、作者、
依赖项的信息,package.xml 可以为 colcon 构建工具确定功能包的编译顺序。一个简单的
package.xml 示例如下:
<?xml version="1.0"?><?xml-model
href="http://download.ros.org/schema/package_format3.xsd"
schematypens="http://www.w3.org/2001/XMLSchema"?><package format="3">
<name>pkg01_helloworld_cpp</name>
<version>0.0.0</version>
<description>TODO: Package description</description>
<maintainer email="ros2@todo.todo">ros2</maintainer>
<license>TODO: License declaration</license>
<buildtool_depend>ament_cmake</buildtool_depend>
<depend>rclcpp</depend>


39
<test_depend>ament_lint_auto</test_depend>
<test_depend>ament_lint_common</test_depend>
<export>
<build_type>ament_cmake</build_type>
</export></package>
1.根标签
 <package>:该标签为整个 xml 文件的根标签,format 属性用来声明文件的格式版本。
2.元信息标签
 <name>:包名;
 <version>:包的版本号;
 <description>:包的描述信息;
 <maintainer>:维护者信息;
 <license>:软件协议;
 <url>:包的介绍网址;
 <author>:包的作者信息。
3.依赖项
 <buildtool_depend>:声明编译工具依赖;
 <build_depend>:声明编译依赖;
 <build_export_depend>:声明根据此包构建库所需依赖;
 <exec_depend>:声明执行时依赖;
 <depend>:相当于<build_depend>、<build_export_depend>、<exec_depend>三者的集
成;
 <test_depend>:声明测试依赖;
 <doc_depend>:声明构建文档依赖。
2.CMakeLists.txt
C++功能包中需要配置 CMakeLists.txt 文件,该文件描述了如何构建 C++功能包,一个简单的
CMakeLists.txt 示例如下:
# 声明 cmake 的最低版本
cmake_minimum_required(VERSION 3.8)
# 包名,需要与 package.xml 中的包名一致


40
project(pkg01_helloworld_cpp)
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
add_compile_options(-Wall -Wextra -Wpedantic)
endif()
# find dependencies
find_package(ament_cmake REQUIRED)
# 引入外部依赖包
find_package(rclcpp REQUIRED)
# 映射源文件与可执行文件
add_executable(helloworld src/helloworld.cpp)
# 设置目标依赖库
ament_target_dependencies(
helloworld
"rclcpp"
)
# 定义安装规则
install(TARGETS helloworld
DESTINATION lib/${PROJECT_NAME})
if(BUILD_TESTING)
find_package(ament_lint_auto REQUIRED)


41
# the following line skips the linter which checks for copyrights
# comment the line when a copyright and license is added to all source files
set(ament_cmake_copyright_FOUND TRUE)
# the following line skips cpplint (only works in a git repo)
# comment the line when this package is in a git repo and when
# a copyright and license is added to all source files
set(ament_cmake_cpplint_FOUND TRUE)
ament_lint_auto_find_test_dependencies()
endif()
ament_package()
在示例中关于文件的使用已经通过注释给出了简短说明,其实关于 CMakeLists.txt 的配置是比较复
杂的,后续随着学习的深入,还会给出更多的补充说明。
3.setup.py
Python 功能包中需要配置 setup.py 文件,该文件描述了如何构建 Python 功能包,一个简单的
setup.py 示例如下:
from setuptools import setup
package_name = 'pkg02_helloworld_py'
setup(
name=package_name, # 包名
version='0.0.0', # 版本
packages=[package_name], # 功能包列表
data_files=[ #需要被安装的文件以及安装路径


42
('share/ament_index/resource_index/packages',
['resource/' + package_name]),
('share/' + package_name, ['package.xml']),
],
install_requires=['setuptools'], # 安装依赖
zip_safe=True,
maintainer='ros2', # 维护者
maintainer_email='ros2@todo.todo', # 维护者 email
description='TODO: Package description', # 包描述
license='TODO: License declaration', # 软件协议
tests_require=['pytest'], # 测试依赖
entry_points={
'console_scripts': [
# 映射源文件与可执行文件
'helloworld = pkg02_helloworld_py.helloworld:main'
],
},
)
使用语法可参考上述示例中的注释。
4.操作命令
ROS2 的文件系统核心是功能包,我们可以通过编译指令 colcon 和 ROS2 内置的工具指令 ros2 来
实现功能包的创建、编译、查找与执行等相关操作。
1.创建
新建功能包语法如下:


43
ros2 pkg create 包名 --build-type 构建类型 --dependencies 依赖列表 --node-name 可执行程序名
称
格式解释:
 --build-type:是指功能包的构建类型,有 cmake、ament_cmake、ament_python 三种类
型可选;
 --dependencies:所依赖的功能包列表;
 --node-name:可执行程序的名称,会自动生成对应的源文件并生成配置文件。
2.编译
编译功能包语法如下:
colcon build
或
colcon build --packages-select 功能包列表
前者会构建工作空间下的所有功能包,后者可以构建指定功能包。
3.查找
在 ros2 pkg 命令下包含了多个查询功能包相关信息的参数。
ros2 pkg executables [包名] # 输出所有功能包或指定功能包下的可执行程序。
ros2 pkg list # 列出所有功能包
ros2 pkg prefix 包名 # 列出功能包路径
ros2 pkg xml # 输出功能包的 package.xml 内容
4.执行
执行命令语法如下:
ros2 run 功能包 可执行程序 参数
小提示:
可以通过命令 -h 或命令 --help 来获取命令的帮助文档。


44
1.5.2 ROS2 核心模块
通信与工具是 ROS2 的核心模块,也是我们以后学习和工作的重点所在,本节将会介绍通信和工具
中涉及到的一些知识点。
1.通信模块
通信模块是整个 ROS2 架构中的重中之重,比如你可能想要了解在 ROS2 中是如何控制机器人底
盘运动的?雷达、摄像头、imu、GPS 等这些传感器数据是如何传输到 ROS2 系统的?人机交互时
调用者如何下发指令,机器人又是如何反馈数据的?导航、机械臂等系统性实现不同模块之间是如
何交互数据的......等等,其实这些都离不开通信模块。另外,开发者构建应用程序时,通信部分在
工作内容中占有相当大的比重。
2.功能包应用
功能包的应用主要有三种方式:
1.二进制安装
ROS 官方或社区提供的功能包可以很方便的通过二进制方式安装,安装命令如下:
sudo apt install ros-ROS2 版本代号-功能包名称
小提示:
可以调用 apt search ros-ROS2 版本代号-* | grep -i 关键字格式的命令,根据关
键字查找所需的功能包。
2.源码安装
也可以直接下载官方、社区或其他第三方提供的源代码,一般我们会从 github 获取源码,下载命令
如下:
git clone 仓库地址
源码下载后,需要自行编译。
3.自实现
开发者按照业务需求自己编写功能包实现。
3.分布式
ROS2 是一个分布式架构,不同的 ROS2 设备之间可以方便的实现通信,这在多机器人设备协同中
是极其重要的。


45
4.终端命令与 rqt
在 ROS2 中提供了丰富的命令行工具,可以方便的调试程序、提高开发效率。
rqt 是一个图形化工具,它的功能与命令行工具类似,但是图形化的交互方式更为友好。
示例 1:使用命令行工具在 turtlesim_node 中生成一只新乌龟。
示例 2:使用 rqt 在 turtlesim_node 中生成一只新乌龟。
5.launch 文件
通过 launch 文件,可以批量的启动 ROS2 节点,这是在构建大型项目时启动多节点的常用方式。
示例:一次性启动多个 turtlesim_node 节点。


46
6.TF 坐标变换
TF 坐标变换可以实现机器人不同部件或不同机器人之间的相对位置关系的转换。
示例 1:发布机器人不同部件之间的坐标系关系。
示例 2:使用 turtlesim_node 模拟多机器人编队。


47
7.可视化
ROS2 内置了三维可视化工具 rviz2,它可以图形化的方式显示机器人模型或显示机器人系统中的
一些抽象数据。
示例 1:显示传感器数据。
示例 2:显示机器人模型。
1.5.3 ROS2 技术支持
ROS 社区提供了多种技术支持机制,主要包括:包文档、问答、论坛、包索引以及问题跟踪,每
种机制都有自己的用途,合适的选择技术支持机制可以避免问题的重复提问、减少问题解决时间并
对新思想的交流很有帮助。


48
ROS 包文档
ROS 核心包的文档以及包的特定内容托管在 ROS 包文档上,可以查找到 ROS 的官方教程、文档
和 API 文档。
ROS 问答
如果在学习和工作中,遇到解决不了的问题,那么可以访问 ROS 问答,在 ROS 问答模块已经涉及
到 60000 多个问题且大部分都给出了答案。开发者可以先搜索遇到的问题,如果该问题尚未提出,
那么可以自行发布相关问题(在发布之前请先查看问题发布指南)。
ROS 论坛
在 ROS 论坛我们可以了解 ROS 社区的最新动态。请注意:论坛是发布公告、新闻和讨论共同爱好
的地方,请不要在此提出技术问题或提交异常报告。
ROS 包索引
在 ROS 包索引可以查找特定功能包的信息。
问题跟踪器
当用户发现系统 BUG 或者想请求新功能时,可以在问题跟踪器上提交报告。如果是报告 BUG,那
么请务必提供问题的详细描述、问题产生的环境以及可能有助于开发人员重现问题的任何细节,最
好能够提供调试回溯。
除了上述多种技术支持之外,ROS 社区还会举办一年一度的 ROSCon(ROS 开发者大会),ROSCon
为所有级别的 ROS 开发人员(从初学者到专家)提供了一个机会,所有的开发者可以建立联系、
相互学习、分享想法或是向专家请教。ROSCon 一般为期两天,主要包括技术讲座和一些 ROS 教
程,期间将介绍新的工具和库,也会介绍已有的工具和库的深层次知识。
ROS 官方的目标是让 ROSCon 代表整个 ROS 社区,这个社区是全球性和多样化的。无论你是谁,
无论你做什么,无论在哪,只要对 ROS 感兴趣,那么都希望能够加入 ROSCon。尤其鼓励女性、
少数派成员和其他不具代表性的群体成员参加 ROSCon。
1.5.4 ROS2 应用方向
许多 ROS 团队伴随 ROS 成长到今日,其规模已经发展到足以被认为是独立组织的程度了。在导航、
机械臂、无人驾驶、无人机等诸多领域大放异彩,下面列出了其中的一些团队项目,这些项目对我
们以后的进阶发展,也提供了指导。
NAV2


49
Nav2 项目继承自 ROS Navigation Stack。该项目旨在可以让移动机器人从 A 点安全的移动到 B 点。
它也可以应用于涉及机器人导航的其他应用,例如跟随动态点。Nav2 将用于实现路径规划、运动
控制、动态避障和恢复行为等一系列功能。
OpenCV
OpenCV(Open Source Computer Vision Library)是一个开源的计算机视觉和机器学习软件库。
OpenCV 旨在为计算机视觉应用程序提供通用基础架构,并加速机器感知在商业产品中的使用。
OpenCV 允许企业轻松地使用和修改代码。
MoveIt
MoveIt 是一组 ROS 软件包, 主要包含运动规划、碰撞检测、运动学、3D 感知、操作控制等功能。
它可以用于构建机械臂的高级行为。MoveIt 现在可以用于市面上的大多数机械臂,并被许多大公司
使用。
The Autoware Foundation
Autoware Foundation 是 ROS 下属的非营利组织,支持实现自动驾驶的开源项目。Autoware 基金
会在企业发展和学术研究之间创造协同效应,为每个人提供自动驾驶技术。
F1 Tenth
F1 Tenth 是将模型车改为无人车的竞速赛事,是一个由研究人员、工程师和自主系统爱好者组成的
国际社区。它最初于 2016 年在宾夕法尼亚大学成立,但后来扩展到全球许多其他机构。
microROS
在基于 ROS 的机器人应用中,micro-ROS 正在弥合性能有限的微控制器和一般处理器之间的差距。
micro-ROS 在各种嵌入式硬件上运行,使 ROS 能直接应用于机器人硬件。
Open Robotics
Open Robotics 与全球 ROS 社区合作,为机器人创建开放的软件和硬件平台,包括 ROS1、ROS2、
Gazebo 模拟器和 Ignition 模拟器。Open Robotics 使用这些平台解决一些重要问题,并通过为各
种客户组织提供软件和硬件开发服务来帮助其他人做同样的事情。
PX4
PX4 是一款用于无人机和其他无人驾驶车辆的开源飞行控制软件。该项目为无人机开发人员提供了
一套灵活的工具,用于共享技术并为无人机应用程序创建量身定制解决方案。


50
ROS-Industrial
ROS-Industrial 是一个开源项目,将 ROS 软件的高级功能扩展到工业相关硬件和应用程序。
1.6 本章小结
本章主要介绍了 ROS2 的相关概念以及 ROS2 的环境搭建。
概念相关知识点如下:
 ROS2 概念、发展历程、组成体系以及在机器人领域的优势;
 ROS2 体系框架:文件系统、核心模块、技术支持、应用方向。
环境搭建相关知识点如下:
 ROS2 安装与测试;
 ROS2 的“helloworld”实现;
 ROS2 集成开发环境搭建;
在概念部分,我们以时间轴为参考介绍了 ROS2 的发展历程,以空间轴为参考介绍了 ROS2 的组
成体系,又分别在横向和纵向两个维度介绍了 ROS2 在机器人研发领域的优势。关于 ROS2 的体
系框架则又分别立足微观和宏观的角度介绍了关于 ROS2 的学习内容,介绍了行业的可发展方向。
在环境搭建部分,则介绍了 ROS2 的具体安装流程。通过 helloworld 程序,了解了 ROS2 程序的
编写、编译和执行流程。最后还介绍了如何使用 VSCode 搭建对开发者友好的集成开发环境。至此,
ROS2 的大门已经敞开,向着未来扬帆起航吧,good luck!




51
第 2 章 ROS2 通信机制核心
机器人是一种高度复杂的系统性实现,一个完整的机器人应用程序可能由若干功能模块组成,每个功能模块可能又包
含若干功能点,在不同功能模块、不同功能点之间需要频繁的进行数据交互。比如以导航中的路径规划模块为例:
 路径规划时就需要其他功能模块输入数据,并输出数据以被其他模块调用。
 输入的数据有地图服务提供的地图数据、定位模块提供的机器人位姿数据、
人机交互模块提供的目标点数据......。
 输出的路径信息则被运动控制订阅或是回显在人机交互界面上。
那么这些相对独立的功能模块或功能点之间是如何实现数据交互的呢?在此,我们就需要介绍一下 ROS2 中的通信
机制了。
本章概览
章节 学习内容 学习收获
2.1 通
信机制
简介
通信机制中涉及的
术语。
能够理解 ROS2 通信中的节点、话题、接口等常用术语以及
不同通信模型的数据交互流程。
2.2 话
题通信
话题通信的概念、作
用、应用场景以及编
码实现。
能够理解话题通信的应用场景,涉及的常用概念(发布方、
订阅方、消息接口、话题...),并可以掌握其实现流程,
编写 C++和 Python 代码实现。
2.3 服
务通信
服务通信的概念、作
用、应用场景以及编
码实现。
能够理解服务通信的应用场景,涉及的常用概念(服务端、
客户端、服务接口、话题...),并可以掌握其实现流程,
编写 C++和 Python 代码实现。
2.4 动
作通信
动作通信的概念、作
用、应用场景以及编
码实现。
能够理解动作通信的应用场景,涉及的常用概念(动作服务
端、动作客户端、动作接口、话题...),并可以掌握其实
现流程,编写 C++和 Python 代码实现。
2.5 参
数服务
参数服务的概念、作
用、应用场景以及编
码实现。
能够理解参数服务的应用场景,并可以掌握其实现流程,
编写 C++和 Python 代码实现。
2.6 本
章小结 知识点汇总。 知识点回顾。
案例演示
案例 1:话题通信示例——发布订阅简单的文本消息。


52
案例 2:话题通信示例——发布自定义消息。
案例 3:服务通信示例——求和。


53
案例 4:动作通信示例——带有连续反馈的求和。
案例 5:参数操作示例。


54
2.1 通信机制简介
在 ROS2 中通信方式虽然有多种,但是不同通信方式的组成要素都是类似的,比如:通信是双方或
多方行为、通信时都需要将不同的通信对象关联、都有各自的模型、交互数据时也必然涉及到数据
载体等等。本节将会介绍通信中涉及到的一些术语。
1.节点
在通信时,不论采用何种方式,通信对象的构建都依赖于节点(Node),在 ROS2 中,一般情况下每
个节点都对应某一单一的功能模块(例如:雷达驱动节点可能负责发布雷达消息,摄像头驱动节点
可能负责发布图像消息)。一个完整的机器人系统可能由许多协同工作的节点组成,ROS2 中的单个
可执行文件(C++程序或 Python 程序)可以包含一个或多个节点。
2.话题
话题(Topic)是一个纽带,具有相同话题的节点可以关联在一起,而这正是通信的前提。并且 ROS2
是跨语言的,有的节点可能是使用 C++实现,有的节点可能是使用 Python 实现的,但是只要二者
使用了相同的话题,就可以实现数据的交互。
3.通信模型
不同的通信对象通过话题关联到一起之后,以何种方式实现通信呢?在 ROS2 中,常用的通信模型
有四种:
1.话题通信:是一种单向通信模型,在通信双方中,发布方发布数据,订阅方订阅数据,数据流单
向的由发布方传输到订阅方。
2.服务通信:是一种基于请求响应的通信模型,在通信双方中,客户端发送请求数据到服务端,服
务端响应结果给客户端。
3.动作通信:是一种带有连续反馈的通信模型,在通信双方中,客户端发送请求数据到服务端,服
务端响应结果给客户端,但是在服务端接收到请求到产生最终响应的过程中,会发送连续的反馈信
息到客户端。
4.参数服务:是一种基于共享的通信模型,在通信双方中,服务端可以设置数据,而客户端可以连
接服务端并操作服务端数据。
4.接口
在通信过程中,需要传输数据,就必然涉及到数据载体,也即要以特定格式传输数据。在 ROS2 中,
数据载体称之为接口(interfaces)。通信时使用的数据载体一般需要使用接口文件定义。常用的接口


55
文件有三种:msg 文件、srv 文件与 action 文件。每种文件都可以按照一定格式定义特定数据类型
的“变量”。
1.msg 文件
msg 文件是用于定义话题通信中数据载体的接口文件,一个典型的.msg 文件示例如下。
int64 num1
int64 num2
在文件中声明了一些被传输的类似于 C++变量的数据。
2.srv 文件
srv 文件是用于定义服务通信中数据载体的接口文件,一个典型的.srv 文件示例如下。
int64 num1
int64 num2
--
int64 sum
文件中声明的数据被---分割为两部分,上半部分用于声明请求数据,下半部分用于声明响应数据。
3.action 文件
action 文件使用用于定义动作通信中数据载体的接口文件,一个典型的.action 文件示例如下。
int64 num
--
int64 sum
--
float64 progress
文件中声明的数据被---分割为三部分,上半部分用于声明请求数据,中间部分用于声明响应数据,
下半部分用于声明连续反馈数据。
4.变量类型
不管是何种接口文件,在文件中每行声明的数据都由字段类型和字段名称组成,可以使用的字段类
型有:
 int8, int16, int32, int64 (或者无符号类型: uint*)


56
 float32, float64
 string
 time, duration
 其他 msg 文件
 变长数组和定长数组
ROS 中还有一种特殊类型:Header,标头包含时间戳和 ROS2 中常用的坐标帧信息。许多接口文
件的第一行包含 Header 标头。
另外,需要说明的是:
参数通信的数据无需定义接口文件,参数通信时数据会被封装为参数对象,参数
客户端和服务端操作的都是参数对象。
本阶段大家对数据载体做简单的了解即可,其具体使用后续章节有详细介绍。
准备工作
1.请先创建工作空间 ws01_plumbing,本章以及第 3 章代码部分内容存储在该工作空间下。
2.实际应用中一般建议创建专门的接口功能包定义接口文件,当前教程也遵循这一建议,预先创建
教程所需使用的接口功能包(需要注意的是,目前为止无法在 Python 功能包中定义接口文件),终端
下进入工作空间的 src 目录,执行如下命令:
ros2 pkg create --build-type ament_cmake base_interfaces_demo
该功能包将用于保存本章教程中自定义的接口文件。


57
2.2 话题通信
场景
话题通信是 ROS 中使用频率最高的一种通信模式,话题通信是基于发布订阅模式的,也即:一个
节点发布消息,另一个节点订阅该消息。话题通信的应用场景也极其广泛,比如如下场景:
机器人在执行导航功能,使用的传感器是激光雷达,机器人会采集激光雷达感知
到的信息并计算,然后生成运动控制信息驱动机器人底盘运动。
在该场景中,就不止一次使用到了话题通信。
 以激光雷达信息的采集处理为例,在 ROS 中有一个节点需要时时的发布当前雷达采集到
的数据,导航模块中也有节点会订阅并解析雷达数据。
 再以运动消息的发布为例,导航模块会综合多方面数据实时计算出运动控制信息并发布给
底盘驱动模块,底盘驱动有一个节点订阅运动信息并将其转换成控制电机的脉冲信号。
以此类推,像雷达、摄像头、GPS.... 等等一些传感器数据的采集,也都是使用了话题通信,话题
通信适用于不断更新的数据传输相关的应用场景。
概念
话题通信是一种以发布订阅的方式实现不同节点之间数据传输的通信模型。数据发布对象称为发布
方,数据订阅对象称之为订阅方,发布方和订阅方通过话题相关联,发布方将消息发布在话题上,
订阅方则从该话题订阅消息,消息的流向是单向的。
话题通信的发布方与订阅方是一种多对多的关系,也即,同一话题下可以存在多个发布方,也可以
存在多个订阅方,这意味着数据会出现交叉传输的情况,当然如果没有订阅方,数据传输也会出现
丢失的情况。


58
作用
话题通信一般应用于不断更新的、少逻辑处理的数据传输场景。
关于消息接口
关于消息接口的使用有多种方式:
 在 ROS2 中通过 std_msgs 包封装了一些原生的数据类型,比如:String、Int8、Int16、Int32、
Int64、Float32、Float64、Char、Bool、Empty.... 这些原生数据类型也可以作为话题通信
的载体,不过这些数据一般只包含一个 data 字段,而 std_msgs 包中其他的接口文件也
比较简单,结构的单一意味着功能上的局限性,当传输一些结构复杂的数据时,就显得力
不从心了;
 在 ROS2 中还预定义了许多标准话题消息接口,这在实际工作中有着广泛的应用,比如:
sensor_msgs 包中定义了许多关于传感器消息的接口(雷达、摄像头、点云......),
geometry_msgs 包中则定义了许多几何消息相关的接口(坐标点、坐标系、速度指令......);
 如果上述接口文件都不能满足我们的需求,那么就可以自定义接口消息;
具体如何选型,大家可以根据具体情况具体分析。
2.2 话题通信
场景
话题通信是 ROS 中使用频率最高的一种通信模式,话题通信是基于发布订阅模式的,也即:一个
节点发布消息,另一个节点订阅该消息。话题通信的应用场景也极其广泛,比如如下场景:
机器人在执行导航功能,使用的传感器是激光雷达,机器人会采集激光雷达感知
到的信息并计算,然后生成运动控制信息驱动机器人底盘运动。


59
在该场景中,就不止一次使用到了话题通信。
 以激光雷达信息的采集处理为例,在 ROS 中有一个节点需要时时的发布当前雷达采集到
的数据,导航模块中也有节点会订阅并解析雷达数据。
 再以运动消息的发布为例,导航模块会综合多方面数据实时计算出运动控制信息并发布给
底盘驱动模块,底盘驱动有一个节点订阅运动信息并将其转换成控制电机的脉冲信号。
以此类推,像雷达、摄像头、GPS.... 等等一些传感器数据的采集,也都是使用了话题通信,话题
通信适用于不断更新的数据传输相关的应用场景。
概念
话题通信是一种以发布订阅的方式实现不同节点之间数据传输的通信模型。数据发布对象称为发布
方,数据订阅对象称之为订阅方,发布方和订阅方通过话题相关联,发布方将消息发布在话题上,
订阅方则从该话题订阅消息,消息的流向是单向的。
话题通信的发布方与订阅方是一种多对多的关系,也即,同一话题下可以存在多个发布方,也可以
存在多个订阅方,这意味着数据会出现交叉传输的情况,当然如果没有订阅方,数据传输也会出现
丢失的情况。


60
作用
话题通信一般应用于不断更新的、少逻辑处理的数据传输场景。
关于消息接口
关于消息接口的使用有多种方式:
 在 ROS2 中通过 std_msgs 包封装了一些原生的数据类型,比如:String、Int8、Int16、Int32、
Int64、Float32、Float64、Char、Bool、Empty.... 这些原生数据类型也可以作为话题通信
的载体,不过这些数据一般只包含一个 data 字段,而 std_msgs 包中其他的接口文件也
比较简单,结构的单一意味着功能上的局限性,当传输一些结构复杂的数据时,就显得力
不从心了;
 在 ROS2 中还预定义了许多标准话题消息接口,这在实际工作中有着广泛的应用,比如:
sensor_msgs 包中定义了许多关于传感器消息的接口(雷达、摄像头、点云......),
geometry_msgs 包中则定义了许多几何消息相关的接口(坐标点、坐标系、速度指令......);
 如果上述接口文件都不能满足我们的需求,那么就可以自定义接口消息;
具体如何选型,大家可以根据具体情况具体分析。
2.2.2 话题通信之原生消息(C++)
1.发布方实现
功能包 cpp01_topic 的 src 目录下,新建 C++文件 demo01_talker_str.cpp,并编辑文件,输入如下
内容:
/*
需求:以某个固定频率发送文本“hello world!”,文本后缀编号,每发送一条消息,编号递增 1。
步骤:
1.包含头文件;
2.初始化 ROS2 客户端;
3.定义节点类;


61
3-1.创建发布方;
3-2.创建定时器;
3-3.组织消息并发布。
4.调用 spin 函数,并传入节点对象指针;
5.释放资源。
*/
// 1.包含头文件;#include "rclcpp/rclcpp.hpp"#include "std_msgs/msg/string.hpp"
using namespace std::chrono_literals;
// 3.定义节点类;class MinimalPublisher : public rclcpp::Node
{
public:
MinimalPublisher()
: Node("minimal_publisher"), count_(0)
{
// 3-1.创建发布方;
publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
// 3-2.创建定时器;
timer_ = this->create_wall_timer(500ms, std::bind(&MinimalPublisher::timer_callback,
this));
}
private:
void timer_callback()
{
// 3-3.组织消息并发布。


62
auto message = std_msgs::msg::String();
message.data = "Hello, world! " + std::to_string(count_++);
RCLCPP_INFO(this->get_logger(), "发布的消息:'%s'", message.data.c_str());
publisher_->publish(message);
}
rclcpp::TimerBase::SharedPtr timer_;
rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
size_t count_;
};
int main(int argc, char * argv[]){
// 2.初始化 ROS2 客户端;
rclcpp::init(argc, argv);
// 4.调用 spin 函数,并传入节点对象指针。
rclcpp::spin(std::make_shared<MinimalPublisher>());
// 5.释放资源;
rclcpp::shutdown();
return 0;
}
2.订阅方实现
功能包 cpp01_topic 的 src 目录下,新建 C++文件 demo02_listener_str.cpp,并编辑文件,输入如
下内容:
/*
需求:订阅发布方发布的消息,并输出到终端。
步骤:


63
1.包含头文件;
2.初始化 ROS2 客户端;
3.定义节点类;
3-1.创建订阅方;
3-2.处理订阅到的消息。
4.调用 spin 函数,并传入节点对象指针;
5.释放资源。
*/
// 1.包含头文件;#include "rclcpp/rclcpp.hpp"#include "std_msgs/msg/string.hpp"using
std::placeholders::_1;
// 3.定义节点类;class MinimalSubscriber : public rclcpp::Node
{
public:
MinimalSubscriber()
: Node("minimal_subscriber")
{
// 3-1.创建订阅方;
subscription_ = this->create_subscription<std_msgs::msg::String>("topic", 10,
std::bind(&MinimalSubscriber::topic_callback, this, _1));
}
private:
// 3-2.处理订阅到的消息;
void topic_callback(const std_msgs::msg::String & msg) const
{


64
RCLCPP_INFO(this->get_logger(), "订阅的消息: '%s'", msg.data.c_str());
}
rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
};
int main(int argc, char * argv[]){
// 2.初始化 ROS2 客户端;
rclcpp::init(argc, argv);
// 4.调用 spin 函数,并传入节点对象指针。
rclcpp::spin(std::make_shared<MinimalSubscriber>());
// 5.释放资源;
rclcpp::shutdown();
return 0;
}
3.编辑配置文件
在 C++功能包中,配置文件主要关注 package.xml 与 CMakeLists.txt。
1.package.xml
在创建功能包时,所依赖的功能包已经自动配置了,配置内容如下:
<depend>rclcpp</depend><depend>std_msgs</depend><depend>base_interfaces_demo</depend>
需要说明的是<depend>base_interfaces_demo</depend>在本案例中不是必须的。
2.CMakeLists.txt
CMakeLists.txt 中发布和订阅程序核心配置如下:
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(base_interfaces_demo REQUIRED)


65
add_executable(demo01_talker_str src/demo01_talker_str.cpp)
ament_target_dependencies(
demo01_talker_str
"rclcpp"
"std_msgs"
)
add_executable(demo02_listener_str src/demo02_listener_str.cpp)
ament_target_dependencies(
demo02_listener_str
"rclcpp"
"std_msgs"
)
install(TARGETS
demo01_talker_str
demo02_listener_str
DESTINATION lib/${PROJECT_NAME})
4.编译
终端中进入当前工作空间,编译功能包:
colcon build --packages-select cpp01_topic
5.执行


66
当前工作空间下,启动两个终端,终端 1 执行发布程序,终端 2 执行订阅程序。
终端 1 输入如下指令:
. install/setup.bash
ros2 run cpp01_topic demo01_talker_str
终端 2 输入如下指令:
. install/setup.bash
ros2 run cpp01_topic demo02_listener_str
最终运行结果与案例 1 类似。
2.2.2 话题通信之原生消息(C++)
1.发布方实现
功能包 cpp01_topic 的 src 目录下,新建 C++文件 demo01_talker_str.cpp,并编辑文件,输入如下
内容:
/*
需求:以某个固定频率发送文本“hello world!”,文本后缀编号,每发送一条消息,编号递增 1。
步骤:
1.包含头文件;
2.初始化 ROS2 客户端;
3.定义节点类;
3-1.创建发布方;
3-2.创建定时器;
3-3.组织消息并发布。
4.调用 spin 函数,并传入节点对象指针;
5.释放资源。


67
*/
// 1.包含头文件;#include "rclcpp/rclcpp.hpp"#include "std_msgs/msg/string.hpp"
using namespace std::chrono_literals;
// 3.定义节点类;class MinimalPublisher : public rclcpp::Node
{
public:
MinimalPublisher()
: Node("minimal_publisher"), count_(0)
{
// 3-1.创建发布方;
publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
// 3-2.创建定时器;
timer_ = this->create_wall_timer(500ms, std::bind(&MinimalPublisher::timer_callback,
this));
}
private:
void timer_callback()
{
// 3-3.组织消息并发布。
auto message = std_msgs::msg::String();
message.data = "Hello, world! " + std::to_string(count_++);
RCLCPP_INFO(this->get_logger(), "发布的消息:'%s'", message.data.c_str());
publisher_->publish(message);
}


68
rclcpp::TimerBase::SharedPtr timer_;
rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
size_t count_;
};
int main(int argc, char * argv[]){
// 2.初始化 ROS2 客户端;
rclcpp::init(argc, argv);
// 4.调用 spin 函数,并传入节点对象指针。
rclcpp::spin(std::make_shared<MinimalPublisher>());
// 5.释放资源;
rclcpp::shutdown();
return 0;
}
2.订阅方实现
功能包 cpp01_topic 的 src 目录下,新建 C++文件 demo02_listener_str.cpp,并编辑文件,输入如
下内容:
/*
需求:订阅发布方发布的消息,并输出到终端。
步骤:
1.包含头文件;
2.初始化 ROS2 客户端;
3.定义节点类;
3-1.创建订阅方;
3-2.处理订阅到的消息。


69
4.调用 spin 函数,并传入节点对象指针;
5.释放资源。
*/
// 1.包含头文件;#include "rclcpp/rclcpp.hpp"#include "std_msgs/msg/string.hpp"using
std::placeholders::_1;
// 3.定义节点类;class MinimalSubscriber : public rclcpp::Node
{
public:
MinimalSubscriber()
: Node("minimal_subscriber")
{
// 3-1.创建订阅方;
subscription_ = this->create_subscription<std_msgs::msg::String>("topic", 10,
std::bind(&MinimalSubscriber::topic_callback, this, _1));
}
private:
// 3-2.处理订阅到的消息;
void topic_callback(const std_msgs::msg::String & msg) const
{
RCLCPP_INFO(this->get_logger(), "订阅的消息: '%s'", msg.data.c_str());
}
rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
};
int main(int argc, char * argv[]){


70
// 2.初始化 ROS2 客户端;
rclcpp::init(argc, argv);
// 4.调用 spin 函数,并传入节点对象指针。
rclcpp::spin(std::make_shared<MinimalSubscriber>());
// 5.释放资源;
rclcpp::shutdown();
return 0;
}
3.编辑配置文件
在 C++功能包中,配置文件主要关注 package.xml 与 CMakeLists.txt。
1.package.xml
在创建功能包时,所依赖的功能包已经自动配置了,配置内容如下:
<depend>rclcpp</depend><depend>std_msgs</depend><depend>base_interfaces_demo</depend>
需要说明的是<depend>base_interfaces_demo</depend>在本案例中不是必须的。
2.CMakeLists.txt
CMakeLists.txt 中发布和订阅程序核心配置如下:
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(base_interfaces_demo REQUIRED)
add_executable(demo01_talker_str src/demo01_talker_str.cpp)
ament_target_dependencies(
demo01_talker_str
"rclcpp"


71
"std_msgs"
)
add_executable(demo02_listener_str src/demo02_listener_str.cpp)
ament_target_dependencies(
demo02_listener_str
"rclcpp"
"std_msgs"
)
install(TARGETS
demo01_talker_str
demo02_listener_str
DESTINATION lib/${PROJECT_NAME})
4.编译
终端中进入当前工作空间,编译功能包:
colcon build --packages-select cpp01_topic
5.执行
当前工作空间下,启动两个终端,终端 1 执行发布程序,终端 2 执行订阅程序。
终端 1 输入如下指令:
. install/setup.bash
ros2 run cpp01_topic demo01_talker_str
终端 2 输入如下指令:
. install/setup.bash


72
ros2 run cpp01_topic demo02_listener_str
最终运行结果与案例 1 类似。
2.2.4 话题通信自定义接口消息
自定义接口消息的流程与在功能包中编写可执行程序的流程类似,主要步骤如下:
 创建并编辑 .msg 文件;
 编辑配置文件;
 编译;
 测试。
接下来,我们可以参考案例 2 编译一个 msg 文件,该文件中包含学生的姓名、年龄、身高等字段。
1.创建并编辑 .msg 文件
功能包 base_interfaces_demo 下新建 msg 文件夹,msg 文件夹下新建 Student.msg 文件,文件
中输入如下内容:
string name
int32 age
float64 height
2.编辑配置文件
1.package.xml 文件
在 package.xml 中需要添加一些依赖包,具体内容如下:
<build_depend>rosidl_default_generators</build_depend>
<exec_depend>rosidl_default_runtime</exec_depend>
<member_of_group>rosidl_interface_packages</member_of_group>
2.CMakeLists.txt 文件
为了将.msg 文件转换成对应的 C++和 Python 代码,还需要在 CMakeLists.txt 中添加如下配置:
find_package(rosidl_default_generators REQUIRED)


73
rosidl_generate_interfaces(${PROJECT_NAME}
"msg/Student.msg"
)
3.编译
终端中进入当前工作空间,编译功能包:
colcon build --packages-select base_interfaces_demo
4.测试
编译完成之后,在工作空间下的 install 目录下将生成 Student.msg 文件对应的 C++和 Python 文件,
我们也可以在终端下进入工作空间,通过如下命令查看文件定义以及编译是否正常:
. install/setup.bash
ros2 interface show base_interfaces_demo/msg/Student
正常情况下,终端将会输出与 Student.msg 文件一致的内容。


74
2.2.5 话题通信之自定义消息(C++)
准备
C++文件中包含自定义消息相关头文件时,可能会抛出异常,可以配置 VSCode
中 c_cpp_properties.json 文件,在文件中的 includePath 属性下添加一行:
"${workspaceFolder}/install/base_interfaces_demo/include/**"
添加完毕后,包含相关头文件时,就不会抛出异常了,其他接口文件或接口包的
使用也与此同理。
1.发布方实现
功能包 cpp01_topic 的 src 目录下,新建 C++文件 demo01_talker_stu.cpp,并编辑文件,输入如
下内容:
/*
需求:以某个固定频率发送文本学生信息,包含学生的姓名、年龄、身高等数据。
*/
// 1.包含头文件;#include "rclcpp/rclcpp.hpp"#include
"base_interfaces_demo/msg/student.hpp"
using namespace std::chrono_literals;using base_interfaces_demo::msg::Student;// 3.定义
节点类;class MinimalPublisher : public rclcpp::Node
{
public:
MinimalPublisher()
: Node("student_publisher"), count_(0)
{
// 3-1.创建发布方;
publisher_ = this->create_publisher<Student>("topic_stu", 10);
// 3-2.创建定时器;
timer_ = this->create_wall_timer(500ms, std::bind(&MinimalPublisher::timer_callback,
this));


75
}
private:
void timer_callback()
{
// 3-3.组织消息并发布。
auto stu = Student();
stu.name = "张三";
stu.age = count_++;
stu.height = 1.65;
RCLCPP_INFO(this->get_logger(), "学生信息:name=%s,age=%d,height=%.2f",
stu.name.c_str(),stu.age,stu.height);
publisher_->publish(stu);
}
rclcpp::TimerBase::SharedPtr timer_;
rclcpp::Publisher<Student>::SharedPtr publisher_;
size_t count_;
};
int main(int argc, char * argv[]){
// 2.初始化 ROS2 客户端;
rclcpp::init(argc, argv);
// 4.调用 spin 函数,并传入节点对象指针。
rclcpp::spin(std::make_shared<MinimalPublisher>());
// 5.释放资源;


76
rclcpp::shutdown();
return 0;
}
2.订阅方实现
功能包 cpp01_topic 的 src 目录下,新建 C++文件 demo04_listener_stu.cpp,并编辑文件,输入如
下内容:
/*
需求:订阅发布方发布的学生消息,并输出到终端。
*/
// 1.包含头文件;#include "rclcpp/rclcpp.hpp"#include
"base_interfaces_demo/msg/student.hpp"
using std::placeholders::_1;using base_interfaces_demo::msg::Student;// 3.定义节点类;
class MinimalSubscriber : public rclcpp::Node
{
public:
MinimalSubscriber()
: Node("student_subscriber")
{
// 3-1.创建订阅方;
subscription_ = this->create_subscription<Student>("topic_stu", 10,
std::bind(&MinimalSubscriber::topic_callback, this, _1));
}
private:
// 3-2.处理订阅到的消息;
void topic_callback(const Student & msg) const


77
{
RCLCPP_INFO(this->get_logger(), "订阅的学生消息:name=%s,age=%d,height=%.2f",
msg.name.c_str(),msg.age, msg.height);
}
rclcpp::Subscription<Student>::SharedPtr subscription_;
};
int main(int argc, char * argv[]){
// 2.初始化 ROS2 客户端;
rclcpp::init(argc, argv);
// 4.调用 spin 函数,并传入节点对象指针。
rclcpp::spin(std::make_shared<MinimalSubscriber>());
// 5.释放资源;
rclcpp::shutdown();
return 0;
}
3.编辑配置文件
package.xml 无需修改,CMakeLists.txt 文件需要添加如下内容:
add_executable(demo03_talker_stu src/demo03_talker_stu.cpp)
ament_target_dependencies(
demo03_talker_stu
"rclcpp"
"std_msgs"
"base_interfaces_demo"
)


78
add_executable(demo04_listener_stu src/demo04_listener_stu.cpp)
ament_target_dependencies(
demo04_listener_stu
"rclcpp"
"std_msgs"
"base_interfaces_demo"
)
文件中 install 修改为如下内容:
install(TARGETS
demo01_talker_str
demo02_listener_str
demo03_talker_stu
demo04_listener_stu
DESTINATION lib/${PROJECT_NAME})
4.编译
终端中进入当前工作空间,编译功能包:
colcon build --packages-select cpp01_topic
5.执行
当前工作空间下,启动两个终端,终端 1 执行发布程序,终端 2 执行订阅程序。
终端 1 输入如下指令:
. install/setup.bash
ros2 run cpp01_topic demo03_talker_stu
终端 2 输入如下指令:


79
. install/setup.bash
ros2 run cpp01_topic demo04_listener_stu
最终运行结果与案例 2 类似。
2.2.6 话题通信之自定义消息(Python)
准备
Python 文件中导入自定义消息相关的包时,为了方便使用,可以配置 VSCode 中
settings.json 文件,在文件中的 python.autoComplete.extraPaths 和
python.analysis.extraPaths 属性下添加一行:
"${workspaceFolder}/install/base_interfaces_demo/local/lib/python3.10/dist-pac
kages"
添加完毕后,代码可以高亮显示且可以自动补齐,其他接口文件或接口包的使用
也与此同理。
1.发布方实现
功能包 py01_topic 的 py01_topic 目录下,新建 Python 文件 demo03_talker_stu_py.py,并编辑文
件,输入如下内容:
"""
需求:以某个固定频率发送文本学生信息,包含学生的姓名、年龄、身高等数据。
"""# 1.导包;import rclpyfrom rclpy.node import Nodefrom base_interfaces_demo.msg import
Student
# 3.定义节点类;class MinimalPublisher(Node):
def __init__(self):
super().__init__('stu_publisher_py')
# 3-1.创建发布方;
self.publisher_ = self.create_publisher(Student, 'topic_stu', 10)


80
# 3-2.创建定时器;
timer_period = 0.5
self.timer = self.create_timer(timer_period, self.timer_callback)
self.i = 0
# 3-3.组织消息并发布。
def timer_callback(self):
stu = Student()
stu.name = "李四"
stu.age = self.i
stu.height = 1.70
self.publisher_.publish(stu)
self.get_logger().info('发布的学生消息(py): name=%s,age=%d,height=%.2f' %
(stu.name, stu.age, stu.height))
self.i += 1
def main(args=None):
# 2.初始化 ROS2 客户端;
rclpy.init(args=args)
# 4.调用 spin 函数,并传入节点对象;
minimal_publisher = MinimalPublisher()
rclpy.spin(minimal_publisher)
# 5.释放资源。
rclpy.shutdown()


81
if __name__ == '__main__':
main()
2.订阅方实现
功能包 py01_topic 的 py01_topic 目录下,新建 Python 文件 demo04_listener_stu_py.py,并编辑
文件,输入如下内容:
"""
需求:订阅发布方发布的学生消息,并输出到终端。
"""
# 1.导包;import rclpyfrom rclpy.node import Nodefrom base_interfaces_demo.msg import
Student
# 3.定义节点类;class MinimalSubscriber(Node):
def __init__(self):
super().__init__('stu_subscriber_py')
# 3-1.创建订阅方;
self.subscription = self.create_subscription(
Student,
'topic_stu',
self.listener_callback,
10)
self.subscription
# 3-2.处理订阅到的消息。
def listener_callback(self, stu):


82
self.get_logger().info('订阅的消息(py): name=%s,age=%d,height=%.2f' % (stu.name,
stu.age, stu.height))
def main(args=None):
# 2.初始化 ROS2 客户端;
rclpy.init(args=args)
# 4.调用 spin 函数,并传入节点对象;
minimal_subscriber = MinimalSubscriber()
rclpy.spin(minimal_subscriber)
# 5.释放资源。
rclpy.shutdown()
if __name__ == '__main__':
main()
3.编辑配置文件
package.xml 无需修改,需要修改 setup.py 文件,entry_points 字段的 console_scripts 中修改为
如下内容:
entry_points={
'console_scripts': [
'demo01_talker_str_py = py01_topic.demo01_talker_str_py:main',
'demo02_listener_str_py = py01_topic.demo02_listener_str_py:main',
'demo03_talker_stu_py = py01_topic.demo03_talker_stu_py:main',
'demo04_listener_stu_py = py01_topic.demo04_listener_stu_py:main'


83
],
},
4.编译
终端中进入当前工作空间,编译功能包:
colcon build --packages-select py01_topic
5.执行
当前工作空间下,启动两个终端,终端 1 执行发布程序,终端 2 执行订阅程序。
终端 1 输入如下指令:
. install/setup.bash
ros2 run py01_topic demo03_talker_stu_py
终端 2 输入如下指令:
. install/setup.bash
ros2 run py01_topic demo04_listener_stu_py
最终运行结果与案例 2 类似。


84
2.3 服务通信
场景
服务通信也是 ROS 中一种极其常用的通信模式,服务通信是基于请求响应模式的,是一种应答机
制。也即:一个节点 A 向另一个节点 B 发送请求,B 接收处理请求并产生响应结果返回给 A。比如
如下场景:
机器人巡逻过程中,控制系统分析传感器数据发现可疑物体或人... 此时需要拍摄
照片并留存。
在上述场景中,就使用到了服务通信。
 数据分析节点 A 需要向相机相关节点 B 发送图片存储请求,节点 B 处理请求,并返回处理
结果。
与上述应用类似的,服务通信更适用于对实时性有要求、具有一定逻辑处理的应用场景。
概念
服务通信是以请求响应的方式实现不同节点之间数据传输的通信模式。发送请求数据的对象称为客
户端,接收请求并发送响应的对象称之为服务端,同话题通信一样,客户端和服务端也通过话题相
关联,不同的是服务通信的数据传输是双向交互式的。
服务通信中,服务端与客户端是一对多的关系,也即,同一服务话题下,存在多个客户端,每个客
户端都可以向服务端发送请求。


85
作用
用于偶然的、对实时性有要求、有一定逻辑处理需求的数据传输场景。
2.3.1 案例以及案例分析
1.案例需求
需求:编写服务通信,客户端可以提交两个整数到服务端,服务端接收请求并解析两个整数求和,
然后将结果响应回客户端。
2.案例分析
在上述案例中,需要关注的要素有三个:


86
 客户端;
 服务端;
 消息载体。
3.流程简介
案例实现前需要先自定义服务接口,接口准备完毕后,服务实现主要步骤如下:
 编写服务端实现;
 编写客户端实现;
 编辑配置文件;
 编译;
 执行。
案例我们会采用 C++和 Python 分别实现,二者都遵循上述实现流程。
4.准备工作
终端下进入工作空间的 src 目录,调用如下两条命令分别创建 C++功能包和 Python 功能包。
ros2 pkg create cpp02_service --build-type ament_cmake --dependencies rclcpp
base_interfaces_demo
ros2 pkg create py02_service --build-type ament_python --dependencies rclpy
base_interfaces_demo
2.3.2 服务通信接口消息
定义服务接口消息与定义话题接口消息流程类似,主要步骤如下:
1. 创建并编辑 .srv 文件;
2. 编辑配置文件;
3. 编译;
4. 测试。
接下来,我们可以参考案例编写一个 srv 文件,该文件中包含请求数据(两个整型字段)与响应数据(一
个整型字段)。
1.创建并编辑 .srv 文件


87
功能包 base_interfaces_demo 下新建 srv 文件夹,srv 文件夹下新建 AddInts.srv 文件,文件中输
入如下内容:
int32 num1
int32 num2
--
int32 sum
2.编辑配置文件
1.package.xml 文件
srv 文件与 msg 文件的包依赖一致,如果你是新建的功能包添加 srv 文件,那么直接参考定义 msg
文件时 package.xml 配置即可。由于我们使用的是 base_interfaces_demo 该包已经为 msg 文件
配置过了依赖包,所以 package.xml 不需要做修改。
2.CMakeLists.txt 文件
如果是新建的功能包,与之前定义 msg 文件同理,为了将.srv 文件转换成对应的 C++和 Python
代码,还需要在 CMakeLists.txt 中添加如下配置:
find_package(rosidl_default_generators REQUIRED)
rosidl_generate_interfaces(${PROJECT_NAME}
"srv/AddInts.srv"
)
不过,我们当前使用的 base_interfaces_demo 包,那么你只需要修改 rosidl_generate_interfaces
函数即可,修改后的内容如下:
rosidl_generate_interfaces(${PROJECT_NAME}
"msg/Student.msg"
"srv/AddInts.srv"
)
3.编译


88
终端中进入当前工作空间,编译功能包:
colcon build --packages-select base_interfaces_demo
4.测试
编译完成之后,在工作空间下的 install 目录下将生成 AddInts.srv 文件对应的 C++和 Python 文件,
我们也可以在终端下进入工作空间,通过如下命令查看文件定义以及编译是否正常:
. install/setup.bash
ros2 interface show base_interfaces_demo/srv/AddInts
正常情况下,终端将会输出与 AddInts.srv 文件一致的内容。
2.3.3 服务通信(C++)
1.服务端实现
功能包 cpp02_service 的 src 目录下,新建 C++文件 demo01_server.cpp,并编辑文件,输入如下
内容:
/*
需求:编写服务端,接收客户端发送请求,提取其中两个整型数据,相加后将结果响应回客户端。
步骤:
1.包含头文件;
2.初始化 ROS2 客户端;
3.定义节点类;
3-1.创建服务端;
3-2.处理请求数据并响应结果。
4.调用 spin 函数,并传入节点对象指针;


89
5.释放资源。
*/
// 1.包含头文件;#include "rclcpp/rclcpp.hpp"#include
"base_interfaces_demo/srv/add_ints.hpp"
using base_interfaces_demo::srv::AddInts;
using std::placeholders::_1;using std::placeholders::_2;
// 3.定义节点类;class MinimalService: public rclcpp::Node{
public:
MinimalService():Node("minimal_service"){
// 3-1.创建服务端;
server = this->create_service<AddInts>("add_ints",std::bind(&MinimalService::add,
this, _1, _2));
RCLCPP_INFO(this->get_logger(),"add_ints 服务端启动完毕,等待请求提交...");
}
private:
rclcpp::Service<AddInts>::SharedPtr server;
// 3-2.处理请求数据并响应结果。
void add(const AddInts::Request::SharedPtr req,const AddInts::Response::SharedPtr
res){
res->sum = req->num1 + req->num2;
RCLCPP_INFO(this->get_logger(),"请求数据:(%d,%d),响应结果:%d", req->num1, req->num2,
res->sum);
}
};
int main(int argc, char const *argv[]){
// 2.初始化 ROS2 客户端;


90
rclcpp::init(argc,argv);
// 4.调用 spin 函数,并传入节点对象指针;
auto server = std::make_shared<MinimalService>();
rclcpp::spin(server);
// 5.释放资源。
rclcpp::shutdown();
return 0;
}
2.客户端实现
功能包 cpp02_service 的 src 目录下,新建 C++文件 demo02_client.cpp,并编辑文件,输入如下
内容:
/*
需求:编写客户端,发送两个整型变量作为请求数据,并处理响应结果。
步骤:
1.包含头文件;
2.初始化 ROS2 客户端;
3.定义节点类;
3-1.创建客户端;
3-2.等待服务连接;
3-3.组织请求数据并发送;
4.创建对象指针调用其功能,并处理响应;
5.释放资源。